<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id/>
    <title>NotionNext BLOG</title>
    <updated>2024-02-02T10:12:32.853Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <author>
        <name>bhwa233</name>
        <uri>https://tangly1024.com</uri>
    </author>
    <link rel="alternate" href="https://tangly1024.com/"/>
    <subtitle>这是一个由NotionNext生成的站点</subtitle>
    <icon>https://tangly1024.com/favicon.png</icon>
    <rights>All rights reserved 2024, bhwa233</rights>
    <entry>
        <title type="html"><![CDATA[vue3 最佳实践]]></title>
        <id>https://tangly1024.com/article/5813c915-3e1e-4a40-a7cd-80ddee150f5c</id>
        <link href="https://tangly1024.com/article/5813c915-3e1e-4a40-a7cd-80ddee150f5c"/>
        <updated>2024-02-01T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<div id="notion-article" class="mx-auto overflow-hidden "><main class="notion light-mode notion-page notion-block-5813c9153e1e4a40a7cd80ddee150f5c"><div class="notion-viewport"></div><div class="notion-collection-page-properties"></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-6cebca6afea14cfb88658479e6426c80" data-id="6cebca6afea14cfb88658479e6426c80"><span><div id="6cebca6afea14cfb88658479e6426c80" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6cebca6afea14cfb88658479e6426c80" title="基础功能"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">基础功能</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-7a15a25692ab429d848668d87cb8a188" data-id="7a15a25692ab429d848668d87cb8a188"><span><div id="7a15a25692ab429d848668d87cb8a188" class="notion-header-anchor"></div><a class="notion-hash-link" href="#7a15a25692ab429d848668d87cb8a188" title="ref声明响应式状态"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>ref</b></code><b>声明响应式状态</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-e1767fc0cf1c448b8dd40afe376d001a"><li>ref的作用是将基本类型转换为响应式对象。</li></ul><ul class="notion-list notion-list-disc notion-block-72b315d469624ed6a81d5209c83f2d05"><li>可以声明基本数据类型或对象类型，返回一个包含value属性的对象。</li></ul><ul class="notion-list notion-list-disc notion-block-059fde697e6c440d9589c8fc73106c39"><li>在<code class="notion-inline-code">&lt;script&gt;</code>里使用需要附加<code class="notion-inline-code">.value</code>。</li></ul><ul class="notion-list notion-list-disc notion-block-01b4f8f72d72474988d4ec7919de6da7"><li>在模板中会自动解包，不需要附加<code class="notion-inline-code">.value</code>。</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-1a07d643db914b2a8cb61319346da0b6" data-id="1a07d643db914b2a8cb61319346da0b6"><span><div id="1a07d643db914b2a8cb61319346da0b6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1a07d643db914b2a8cb61319346da0b6" title="reactive声明响应式对象"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>reactive</b></code><b>声明响应式对象</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-e8e92486666744d09e76df6d03040aa4"><li>reactive的作用是让对象的属性变成响应式的，可以在模板中直接使用。</li></ul><ul class="notion-list notion-list-disc notion-block-41f9fb1d72054ad687045acac51f5639"><li>接受一个对象作为参数，返回一个响应式代理对象。</li></ul><ul class="notion-list notion-list-disc notion-block-c1c286094cf64a0fb38c1d72d4c2fb55"><li>只能声明引用型数据类型。</li></ul><ul class="notion-list notion-list-disc notion-block-63ba4f67057146f2aceee3c3931d95af"><li>不需要附加<code class="notion-inline-code">.value</code>。</li></ul><ul class="notion-list notion-list-disc notion-block-abbd50ef75b641a185d5529cba1305a8"><li>不能重新赋值，否则会失去响应式。</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-89b6915593c447ada2c20bf2facdd9e0" data-id="89b6915593c447ada2c20bf2facdd9e0"><span><div id="89b6915593c447ada2c20bf2facdd9e0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#89b6915593c447ada2c20bf2facdd9e0" title="refvs Reactive"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>ref</b></code><b>vs </b><code class="notion-inline-code"><b>Reactive</b></code></span></span></h3><div class="notion-text notion-block-062104db0e324597be2b704d450438cd"><b>推荐使用ref。</b></div><table class="notion-simple-table notion-block-d0513eb996b04af588711eed623b055c"><tbody><tr class="notion-simple-table-row notion-block-56a2053650274c799250a7defba56e42"><td class="" style="width:120px"><div class="notion-simple-table-cell"><b>reactive</b></div></td><td class="" style="width:120px"><div class="notion-simple-table-cell"><b>ref</b></div></td></tr><tr class="notion-simple-table-row notion-block-1d1fc75ea25648ee831583b913ca0b35"><td class="" style="width:120px"><div class="notion-simple-table-cell">✅ script 和 template 无差别</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">❌ script 中需要使用 .value</div></td></tr><tr class="notion-simple-table-row notion-block-5af645a54ab146abbd5c67ab913b3595"><td class="" style="width:120px"><div class="notion-simple-table-cell">❌ 只支持对象和数组</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">✅ 任意类型</div></td></tr><tr class="notion-simple-table-row notion-block-1db6c4c9d4254056ac4fc9b295a6ee94"><td class="" style="width:120px"><div class="notion-simple-table-cell">❌ 传递函数会丢失响应式</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">✅ 传递函数不会丢失响应式</div></td></tr><tr class="notion-simple-table-row notion-block-8235a695a519482daf1ed8950e06e5c2"><td class="" style="width:120px"><div class="notion-simple-table-cell">✅ 直接返回属性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">✅ 使用 .value 访问属性</div></td></tr><tr class="notion-simple-table-row notion-block-c5e63a06c25348cf9ba6efb55e8cd63c"><td class="" style="width:120px"><div class="notion-simple-table-cell">❌ 解构丢失响应式</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">❌ 解构丢失响应式</div></td></tr></tbody></table><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-802134ab7b944d398909ae092c710c93" data-id="802134ab7b944d398909ae092c710c93"><span><div id="802134ab7b944d398909ae092c710c93" class="notion-header-anchor"></div><a class="notion-hash-link" href="#802134ab7b944d398909ae092c710c93" title="computed 计算属性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>computed</b></code><b> 计算属性</b></span></span></h3><div class="notion-text notion-block-1852802949324518a80b73192fd8bb0f"><code class="notion-inline-code">computed</code> 缓存计算属性值，</div><ul class="notion-list notion-list-disc notion-block-6b3b4fc37d824e309e6f15caf06c21fe"><li>懒计算：没有被引用不会计算。</li></ul><ul class="notion-list notion-list-disc notion-block-118d93698a78480c9015571a821f6ca0"><li>缓存属性：计算属性的值会被缓存，只有在相关依赖值改变时，才重新计算。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-3498486a988d44b8a851faf730bfd535" data-id="3498486a988d44b8a851faf730bfd535"><span><div id="3498486a988d44b8a851faf730bfd535" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3498486a988d44b8a851faf730bfd535" title="只读计算属性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>只读计算属性</b></span></span></h4><div class="notion-text notion-block-685204bcd5da46bca4b1fca31e330611">默认创建的是一个<code class="notion-inline-code">只读</code>的计算属性 <code class="notion-inline-code">ref</code></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-6dd57f58b3b04652864feb3eac6bee92" data-id="6dd57f58b3b04652864feb3eac6bee92"><span><div id="6dd57f58b3b04652864feb3eac6bee92" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6dd57f58b3b04652864feb3eac6bee92" title="可写计算属性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>可写计算属性</b></span></span></h4><div class="notion-text notion-block-136eb797fa0e4a38a6750e8e7ecc8869"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cn.vuejs.org/api/reactivity-core.html##computed">Vue.js</a></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-6ae83c98c1464a76968f22dad31ec0a4" data-id="6ae83c98c1464a76968f22dad31ec0a4"><span><div id="6ae83c98c1464a76968f22dad31ec0a4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6ae83c98c1464a76968f22dad31ec0a4" title="watch监听"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>watch</b></code><b>监听</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-801bf0867c2440bbb6bb0ceb1b88bcf1"><li>需要显式声明响应式依赖</li></ul><ul class="notion-list notion-list-disc notion-block-da993197410e4beda4d6adf394a853bd"><li>默认初始化不会执行，配置参数<code class="notion-inline-code">immediate</code></li></ul><ul class="notion-list notion-list-disc notion-block-2abf8ccc29af41e3b122769d67c1cc12"><li>默认只会浅层监听，配置参数<code class="notion-inline-code">deep</code></li></ul><ul class="notion-list notion-list-disc notion-block-6f677e8b955b481a991329339b87973a"><li>默认在组件更新前执行，配置参数<code class="notion-inline-code"><b>flush</b></code></li></ul><ul class="notion-list notion-list-disc notion-block-1099719669d2478bbf2fb94275c91f9b"><li>函数返回值都是停止监听的函数</li></ul><ul class="notion-list notion-list-disc notion-block-34943f78728748d08acf0a3301e6d2f0"><li>callback参数为新旧值，返回值为可清除副作用</li></ul><ul class="notion-list notion-list-disc notion-block-172e176caf0f47f3b855ae6e2ea11294"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html##computed-debugging">计算属性调试</a></li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-29f8a7ff11ee41288005e7e20caa4a43" data-id="29f8a7ff11ee41288005e7e20caa4a43"><span><div id="29f8a7ff11ee41288005e7e20caa4a43" class="notion-header-anchor"></div><a class="notion-hash-link" href="#29f8a7ff11ee41288005e7e20caa4a43" title="监听getter函数"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>监听getter函数</b></span></span></h4><div class="notion-text notion-block-8e37d9cafc8444deb46b9368174b0265">需要指向具体的属性</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-42e779a60b7040c993fa0fbdfdb5924c" data-id="42e779a60b7040c993fa0fbdfdb5924c"><span><div id="42e779a60b7040c993fa0fbdfdb5924c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#42e779a60b7040c993fa0fbdfdb5924c" title="侦听一个 ref"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>侦听一个 </b><code class="notion-inline-code"><b>ref</b></code></span></span></h4><div class="notion-text notion-block-9b2dbae049fa4b77838103d547dcb01e">侦听响应式对象时侦听器会自动启用深层模式。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-11c7d564675a42bc830d254e4e81938e" data-id="11c7d564675a42bc830d254e4e81938e"><span><div id="11c7d564675a42bc830d254e4e81938e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#11c7d564675a42bc830d254e4e81938e" title="watchEffect 监听副作用"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>watchEffect</b></code><b> 监听副作用</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-23e2948381de4a1298edc36ef35ea649"><li>自动跟踪回调的响应式依赖</li></ul><ul class="notion-list notion-list-disc notion-block-6ccaf502ada84666bcf951c76398113b"><li>初始化会执行</li></ul><ul class="notion-list notion-list-disc notion-block-4cc7b27d68a84b709b5cdf82906d2e89"><li>不会深度监听</li></ul><ul class="notion-list notion-list-disc notion-block-b3d9eaf718a347b2a3ed47a193505b5f"><li>默认在组件更新前执行，配置参数<code class="notion-inline-code"><b>flush</b></code></li></ul><ul class="notion-list notion-list-disc notion-block-ee11167abd38496aa82590cb256b9a33"><li>函数返回值都是停止监听的函数</li></ul><ul class="notion-list notion-list-disc notion-block-2ebbe96e09bb43f79ad78f4fb291c7ed"><li>callback无法获取旧值，返回值为可清除副作用</li></ul><ul class="notion-list notion-list-disc notion-block-5a7c5140495849e0b764e5a9dac17161"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html##computed-debugging">计算属性调试</a></li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-d437deb6a78c4b3f8d1b87fb831c284d" data-id="d437deb6a78c4b3f8d1b87fb831c284d"><span><div id="d437deb6a78c4b3f8d1b87fb831c284d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d437deb6a78c4b3f8d1b87fb831c284d" title="监听源"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>监听源</b></span></span></h4><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-cc316a64b844458e943c7452ed008eee" data-id="cc316a64b844458e943c7452ed008eee"><span><div id="cc316a64b844458e943c7452ed008eee" class="notion-header-anchor"></div><a class="notion-hash-link" href="#cc316a64b844458e943c7452ed008eee" title="unref 解包"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>unref</b></code><b> 解包</b></span></span></h3><div class="notion-text notion-block-c5ae96f154e0456789e3c5c8860ec072">防止在一个非<code class="notion-inline-code">ref</code>上调用<code class="notion-inline-code">.value</code>会抛出一个运行时错误。</div><div class="notion-text notion-block-6102fadf976d4d50ab0d5d36e338fc60">如果<code class="notion-inline-code">unref()</code>的参数是一个<code class="notion-inline-code">ref</code>，就会返回其内部值。否则就返回参数本身。这是的<code class="notion-inline-code">val = isRef(val) ? val.value : val</code>语法糖。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-ef4eefb4d62b4429b04e7e147087391d" data-id="ef4eefb4d62b4429b04e7e147087391d"><span><div id="ef4eefb4d62b4429b04e7e147087391d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ef4eefb4d62b4429b04e7e147087391d" title="toRefs 和 toRef解构响应式对象"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>toRefs</b></code><b> 和 </b><code class="notion-inline-code"><b>toRef</b></code><b>解构响应式对象</b></span></span></h3><div class="notion-text notion-block-1268aadaaa0a41de9e9fba924c820e96">用 <code class="notion-inline-code">toRefs()</code> 和 <code class="notion-inline-code">toRef()</code> 解构响应式对象，保持响应性。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-538b4c566fd2414b959d9248c0297ca8" data-id="538b4c566fd2414b959d9248c0297ca8"><span><div id="538b4c566fd2414b959d9248c0297ca8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#538b4c566fd2414b959d9248c0297ca8" title="readonly 返回一个只读的值"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>readonly</b></code><b> 返回一个只读的值</b></span></span></h3><div class="notion-text notion-block-9007a98f8e60449ca2d15793bd6841f7">接受一个对象 (不论是响应式还是普通的)，返回一个原值的只读代理。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e90de2090544471b8e322fe9aa546aa7" data-id="e90de2090544471b8e322fe9aa546aa7"><span><div id="e90de2090544471b8e322fe9aa546aa7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e90de2090544471b8e322fe9aa546aa7" title="isRef 检查某个值是否为 ref。"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>isRef</b></code><b> 检查某个值是否为 ref。</b></span></span></h3><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-32b2e6c781184699bc57862b518bb294" data-id="32b2e6c781184699bc57862b518bb294"><span><div id="32b2e6c781184699bc57862b518bb294" class="notion-header-anchor"></div><a class="notion-hash-link" href="#32b2e6c781184699bc57862b518bb294" title="provide +inject依赖注入"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>provide</b></code><b> +</b><code class="notion-inline-code"><b>inject</b></code><b>依赖注入</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-f60ff2b7b46c4b33b28431f55cac6a5e"><li><code class="notion-inline-code">provide</code> 在祖先组件提供值。接受两个参数：第一个参数是要注入的 <code class="notion-inline-code">key</code>，可以是一个字符串或者一个 <code class="notion-inline-code">symbol</code>，第二个参数是要注入的值。</li></ul><ul class="notion-list notion-list-disc notion-block-04c463d80a30421d94381f30643c270f"><li><code class="notion-inline-code">inject</code> 在后代组件接收值。第一个参数是注入的 <code class="notion-inline-code">key</code>。<code class="notion-inline-code">Vue</code> 会查找最近组件的提供值
。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-778b017817a6405582fdfb832cfc6973" data-id="778b017817a6405582fdfb832cfc6973"><span><div id="778b017817a6405582fdfb832cfc6973" class="notion-header-anchor"></div><a class="notion-hash-link" href="#778b017817a6405582fdfb832cfc6973" title="父组件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>父组件</b></span></span></h4><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-49d0f054565741929eef6e449a5ac05f" data-id="49d0f054565741929eef6e449a5ac05f"><span><div id="49d0f054565741929eef6e449a5ac05f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#49d0f054565741929eef6e449a5ac05f" title="子组件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>子组件</b></span></span></h4><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-71769cddb516495ca1905d4a12f284e2" data-id="71769cddb516495ca1905d4a12f284e2"><span><div id="71769cddb516495ca1905d4a12f284e2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#71769cddb516495ca1905d4a12f284e2" title="子组件调用父组件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">子组件调用父组件</span></span></h3><ul class="notion-list notion-list-disc notion-block-b356d197124f4b888e89fe802aae54e1"><li>props</li></ul><ul class="notion-list notion-list-disc notion-block-5ffe6b0176bd44d4ab07790c96a87cb2"><li>依赖注入</li></ul><ul class="notion-list notion-list-disc notion-block-fc8418b3374249eb828a8503732bad2d"><li>状态管理</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-4093c654e82d40e7a8d5ed377b3392da" data-id="4093c654e82d40e7a8d5ed377b3392da"><span><div id="4093c654e82d40e7a8d5ed377b3392da" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4093c654e82d40e7a8d5ed377b3392da" title="父组件调用子组件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">父组件调用子组件</span></span></h3><div class="notion-text notion-block-ab4c6210f9d846439289aefb69684da5">子组件里定义一个方法，并使用<code class="notion-inline-code">defineExpose</code>将其导出。父组件里将子组件通过<code class="notion-inline-code">ref</code> 来拿到子组件上的方法。</div><div class="notion-text notion-block-0d83f81b28a145469e8fc1419aaf2e4e">子组件</div><div class="notion-text notion-block-d0c9aa999dfc4ce2bcb097571af1ea46">父组件</div><div class="notion-blank notion-block-5e21892d4d6e4f46be4d0ebfc817ff70"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-faf379136f8a48819e88afc667841830" data-id="faf379136f8a48819e88afc667841830"><span><div id="faf379136f8a48819e88afc667841830" class="notion-header-anchor"></div><a class="notion-hash-link" href="#faf379136f8a48819e88afc667841830" title="生命周期"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cn.vuejs.org/api/composition-api-lifecycle.html"><b>生命周期</b></a></span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-2950a82796d944cb9d6847bf532fef54" data-id="2950a82796d944cb9d6847bf532fef54"><span><div id="2950a82796d944cb9d6847bf532fef54" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2950a82796d944cb9d6847bf532fef54" title="组件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">组件</span></span></h3><ul class="notion-list notion-list-disc notion-block-54e11c65166946949a7490f529cc0c66"><li><code class="notion-inline-code">onUpdated</code> 响应状态变更而更新<code class="notion-inline-code">DOM</code>树之后</li></ul><ul class="notion-list notion-list-disc notion-block-e2a14c06b0d64ab793afeceb0567f351"><li><code class="notion-inline-code">onUnmounted</code> 组件实例被卸载之后</li></ul><ul class="notion-list notion-list-disc notion-block-022946ccaafc4e9b81b314d9c9db74cb"><li><code class="notion-inline-code">onBeforeMount</code> 组件被挂载之前</li></ul><ul class="notion-list notion-list-disc notion-block-9f9452670fa54034915a04ccf2605715"><li><code class="notion-inline-code">onBeforeUnmount</code> 组件实例被卸载之前</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-94066ef418ef4ca49f99270b46d64b36" data-id="94066ef418ef4ca49f99270b46d64b36"><span><div id="94066ef418ef4ca49f99270b46d64b36" class="notion-header-anchor"></div><a class="notion-hash-link" href="#94066ef418ef4ca49f99270b46d64b36" title="错误"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">错误</span></span></h3><ul class="notion-list notion-list-disc notion-block-4b915219ebeb40c19c2709b3e65b7321"><li><code class="notion-inline-code">onErrorCaptured</code> 捕获了后代组件传递的错误时调用</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f60aab5b4420464496cc688567d1c61a" data-id="f60aab5b4420464496cc688567d1c61a"><span><div id="f60aab5b4420464496cc688567d1c61a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f60aab5b4420464496cc688567d1c61a" title="调试"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">调试</span></span></h3><ul class="notion-list notion-list-disc notion-block-8327bb7ef5894db09416cf3532d8ac82"><li><code class="notion-inline-code">onRenderTracked</code> 组件渲染过程中追踪到响应式依赖时</li></ul><ul class="notion-list notion-list-disc notion-block-904fadc6e4ee4141b87349dcecd4e270"><li><code class="notion-inline-code">onRenderTriggered</code> 响应式依赖的变更触发了组件渲染时</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-085ee42cf9124d25b3efe81dd39016de" data-id="085ee42cf9124d25b3efe81dd39016de"><span><div id="085ee42cf9124d25b3efe81dd39016de" class="notion-header-anchor"></div><a class="notion-hash-link" href="#085ee42cf9124d25b3efe81dd39016de" title="SSR"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">SSR</span></span></h3><ul class="notion-list notion-list-disc notion-block-d554e3c7e8cb4bdcbad1e0b894d08cbf"><li><code class="notion-inline-code">onServerPrefetch</code> 组件实例在服务器上被渲染之前（<code class="notion-inline-code">SSR only</code>）</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-483d5dbf5ce54cfeb5a925f249c7918d" data-id="483d5dbf5ce54cfeb5a925f249c7918d"><span><div id="483d5dbf5ce54cfeb5a925f249c7918d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#483d5dbf5ce54cfeb5a925f249c7918d" title="keepAlive"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">keepAlive</span></span></h3><ul class="notion-list notion-list-disc notion-block-133f15016277423f98b4f9e47dde621d"><li><code class="notion-inline-code">onActivated</code> 缓存组件被插入到DOM中时调用</li></ul><ul class="notion-list notion-list-disc notion-block-75b5ceccd62246089e68c6e21630e673"><li><code class="notion-inline-code">onDeactivated</code> 当缓存组件从<code class="notion-inline-code">DOM</code>中被移除时调用</li></ul><div class="notion-blank notion-block-ea75826fb8dc43a48d898772b1d6d8b4"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-7cd2b004e2364ab3bff66d377556cf59" data-id="7cd2b004e2364ab3bff66d377556cf59"><span><div id="7cd2b004e2364ab3bff66d377556cf59" class="notion-header-anchor"></div><a class="notion-hash-link" href="#7cd2b004e2364ab3bff66d377556cf59" title="指令"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">指令</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-96c73e4b5edf45ce9fb579e85ab9d17d" data-id="96c73e4b5edf45ce9fb579e85ab9d17d"><span><div id="96c73e4b5edf45ce9fb579e85ab9d17d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#96c73e4b5edf45ce9fb579e85ab9d17d" title="v-text 更新元素的文本内容"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>v-text</b></code><b> 更新元素的文本内容</b></span></span></h3><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-6db66b6027c244d59d956c3770dca438" data-id="6db66b6027c244d59d956c3770dca438"><span><div id="6db66b6027c244d59d956c3770dca438" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6db66b6027c244d59d956c3770dca438" title="v-html 更新元素的html内容"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>v-html</b></code><b> 更新元素的html内容</b></span></span></h3><div class="notion-text notion-block-d31549487e1748bbbedefb9fac6dd489">注意：在你的站点上动态渲染任意的 HTML 是非常危险的，因为它很容易导致 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FCross-site_scripting">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<b>绝不要</b>将用户提供的内容作为插值</div><div class="notion-blank notion-block-6385c0f84c1b46c88b818242b5c33d8d"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e817de86aa6d4e389f46e03f2e0db38f" data-id="e817de86aa6d4e389f46e03f2e0db38f"><span><div id="e817de86aa6d4e389f46e03f2e0db38f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e817de86aa6d4e389f46e03f2e0db38f" title="v-show 按条件改变元素的可见性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>v-show</b></code><b> 按条件改变元素的可见性</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-d5b6ad4cff3347baaaa91e381c2e7a2d"><li><code class="notion-inline-code">v-show</code> 根据条件切换元素上<code class="notion-inline-code">css</code>的 <code class="notion-inline-code">display</code> 属性，来改变元素可见性。</li></ul><ul class="notion-list notion-list-disc notion-block-a24619d8a21845f5ab33c3100e932ecf"><li><code class="notion-inline-code">v-show</code> 始终会被渲染元素。</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-dad7015f3c9b47ffa2a771fdbfa049c2" data-id="dad7015f3c9b47ffa2a771fdbfa049c2"><span><div id="dad7015f3c9b47ffa2a771fdbfa049c2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#dad7015f3c9b47ffa2a771fdbfa049c2" title="v-if  按条件渲染元素"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>v-if</b></code><b>  按条件渲染元素</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-a53ed60eefb049c2951602f32c4324da"><li> <code class="notion-inline-code">v-if</code> 根据条件判断是否渲染元素</li></ul><div class="notion-blank notion-block-06b71673efc04bde98666b32a0bc417a"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-45eb5b0a8ec04f3882e6adff14d91ccf" data-id="45eb5b0a8ec04f3882e6adff14d91ccf"><span><div id="45eb5b0a8ec04f3882e6adff14d91ccf" class="notion-header-anchor"></div><a class="notion-hash-link" href="#45eb5b0a8ec04f3882e6adff14d91ccf" title="v-if vs. v-show"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>v-if</b></code><b> vs. </b><code class="notion-inline-code"><b>v-show</b></code><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fguide%2Fessentials%2Fconditional.html%23v-if-vs-v-show"><b></b></a></span></span></h3><div class="notion-text notion-block-cc69db92908649e7b3419b6199f563b4"><code class="notion-inline-code">v-if</code> 有更高的切换开销，而 <code class="notion-inline-code">v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code class="notion-inline-code">v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code class="notion-inline-code">v-if</code> 会更合适。</div><div class="notion-blank notion-block-512c088d70f64ddca1047469b9f0f742"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-2df2e06c22a549819740e75e76481f62" data-id="2df2e06c22a549819740e75e76481f62"><span><div id="2df2e06c22a549819740e75e76481f62" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2df2e06c22a549819740e75e76481f62" title="v-on 给元素绑定事件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>v-on</b></code><b> 给元素绑定事件</b></span></span></h3><div class="notion-text notion-block-f33879cba59741558349186423423c75">缩写：<code class="notion-inline-code">@</code></div><ul class="notion-list notion-list-disc notion-block-ce70798a93e844cd9e1d818c3f7615db"><li><b>修饰符</b></li><ul class="notion-list notion-list-disc notion-block-ce70798a93e844cd9e1d818c3f7615db"><li><code class="notion-inline-code">.stop</code> - 调用 <code class="notion-inline-code">event.stopPropagation()</code>。</li><li><code class="notion-inline-code">.prevent</code> - 调用 <code class="notion-inline-code">event.preventDefault()</code>。</li><li><code class="notion-inline-code">.capture</code> - 在捕获模式添加事件监听器。</li><li><code class="notion-inline-code">.self</code> - 只有事件从元素本身发出才触发处理函数。</li><li><code class="notion-inline-code">.{keyAlias}</code> - 只在某些按键下触发处理函数。</li><li><code class="notion-inline-code">.once</code> - 最多触发一次处理函数。</li><li><code class="notion-inline-code">.left</code> - 只在鼠标左键事件触发处理函数。</li><li><code class="notion-inline-code">.right</code> - 只在鼠标右键事件触发处理函数。</li><li><code class="notion-inline-code">.middle</code> - 只在鼠标中键事件触发处理函数。</li><li><code class="notion-inline-code">.passive</code> - 通过 <code class="notion-inline-code">{ passive: true }</code> 附加一个 DOM 事件。</li></ul></ul><div class="notion-blank notion-block-77714e29decd4995965f772f7741552f"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-280f563aba5646c2b40047c0901abc5c" data-id="280f563aba5646c2b40047c0901abc5c"><span><div id="280f563aba5646c2b40047c0901abc5c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#280f563aba5646c2b40047c0901abc5c" title="v-bind  组件绑定属性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>v-bind</b></code><b>  组件绑定属性</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-7b30755c0df9425caee99b90e345d42e"><li>缩写： <code class="notion-inline-code">:</code></li></ul><ul class="notion-list notion-list-disc notion-block-b4cc7ac71835456da84f429b976a4449"><li>用于给组件绑定属性值，可动态绑定一个或多个<code class="notion-inline-code">attribute</code>，也可以是组件<code class="notion-inline-code">prop</code></li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-d8459445e8b049d095914feb5cca74fe" data-id="d8459445e8b049d095914feb5cca74fe"><span><div id="d8459445e8b049d095914feb5cca74fe" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d8459445e8b049d095914feb5cca74fe" title="v-model 双向数据绑定"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>v-model</b></code><b> 双向数据绑定</b></span></span></h3><div class="notion-text notion-block-7ce6a6f3d1764b6fa81b8e5b04fffa2b">在表单输入元素或组件上创建双向绑定。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-46520bbf22534f40a1d8587cb9dc068c" data-id="46520bbf22534f40a1d8587cb9dc068c"><span><div id="46520bbf22534f40a1d8587cb9dc068c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#46520bbf22534f40a1d8587cb9dc068c" title="仅限："><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>仅限：</b></span></span></h4><ul class="notion-list notion-list-disc notion-block-2301e5f62a2d46e3a6950c39dc558591"><li><code class="notion-inline-code">&lt;input&gt;</code></li></ul><ul class="notion-list notion-list-disc notion-block-70dd586365a64a95aeaea2831f4a49cf"><li><code class="notion-inline-code">&lt;select&gt;</code></li></ul><ul class="notion-list notion-list-disc notion-block-f5ad00b5095d4fbaa81b81079998a797"><li><code class="notion-inline-code">&lt;textarea&gt;</code></li></ul><ul class="notion-list notion-list-disc notion-block-efa9fc5df50c4bc48dda359e74f59068"><li>components</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-5e29d575350d45268b21852d65ee73ca" data-id="5e29d575350d45268b21852d65ee73ca"><span><div id="5e29d575350d45268b21852d65ee73ca" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5e29d575350d45268b21852d65ee73ca" title="修饰符"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>修饰符</b></span></span></h4><ul class="notion-list notion-list-disc notion-block-2da31c4915bc42ac92f85ab37a3bc348"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cn.vuejs.org/guide/essentials/forms.html#lazy"><code class="notion-inline-code"><b>.lazy</b></code></a> - 监听 <code class="notion-inline-code">change</code> 事件而不是 <code class="notion-inline-code">input</code></li></ul><ul class="notion-list notion-list-disc notion-block-eabce1c88ec041159ce2cd8a9ecabf54"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cn.vuejs.org/guide/essentials/forms.html#number"><code class="notion-inline-code"><b>.number</b></code></a> - 将输入的合法字符串转为数字</li></ul><ul class="notion-list notion-list-disc notion-block-0bce8ce905c04f6dbdb6d7f9066e20d2"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cn.vuejs.org/guide/essentials/forms.html#trim"><code class="notion-inline-code"><b>.trim</b></code></a> - 移除输入内容两端空格</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-5ed77dcc42764cdcb83591770d4ce95e" data-id="5ed77dcc42764cdcb83591770d4ce95e"><span><div id="5ed77dcc42764cdcb83591770d4ce95e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5ed77dcc42764cdcb83591770d4ce95e" title="多个v-model 绑定"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>多个v-model 绑定</b></span></span></h4><div class="notion-text notion-block-f6a1c03d8ce64c87bb391dfeeb957edd">父组件</div><div class="notion-text notion-block-c634f86302fa43ac9f3a227d11e798eb">子组件</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e7f61e1983704eb7be7139a9d085c257" data-id="e7f61e1983704eb7be7139a9d085c257"><span><div id="e7f61e1983704eb7be7139a9d085c257" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e7f61e1983704eb7be7139a9d085c257" title="v-slot 作用域插槽"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>v-slot 作用域插槽</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-0927a287a50c4bbaaca283372e2988f0"><li><b>缩写：</b><code class="notion-inline-code">#</code></li></ul><ul class="notion-list notion-list-disc notion-block-29d00497a3a54479bb646a8ae5953c61"><li>父组件用<code class="notion-inline-code">v-slot</code> 定义一个或多个具名插槽的内容</li></ul><ul class="notion-list notion-list-disc notion-block-b9d64034ed1a4821bfd509a8bb835d7a"><li>子组件使用<code class="notion-inline-code">slot</code> 组件来定义的插槽位置，并显示父组件定义的内容。</li></ul><div class="notion-text notion-block-30fd96306e614a12a2af0356fcb7bc4d">父组件</div><div class="notion-text notion-block-3c83eded4e9847d5ab3985fdfefad60e">子组件</div><div class="notion-text notion-block-68a60e6bcbd1464f8cc6305524fad356">渲染结果</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-08e8e8912ed7423baa57e377fcbec21b"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:528px;max-width:100%;flex-direction:column"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fde5ea524-b729-4eea-845e-59eaf20e7149%2Fda495a08-105b-4e3a-8e86-39e8f3f19c7b%2FUntitled.png?table=block&amp;id=08e8e891-2ed7-423b-aa57-e377fcbec21b&amp;t=08e8e891-2ed7-423b-aa57-e377fcbec21b&amp;width=528&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><div class="notion-blank notion-block-d65b5591cf1c43baa5578cfa5c4262dc"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-093f7b7125c14f3cbf35891dc0b94f6b" data-id="093f7b7125c14f3cbf35891dc0b94f6b"><span><div id="093f7b7125c14f3cbf35891dc0b94f6b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#093f7b7125c14f3cbf35891dc0b94f6b" title="v-pre 跳过该元素及其所有子元素的编译"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code">v-pre</code> <b>跳过该元素及其所有子元素的编译</b></span></span></h3><div class="notion-text notion-block-34fa4851de734e8d96c67edb4225d902">跳过对当前元素及其子元素的编译过程。直接输出元素的原始内容。</div><div class="notion-blank notion-block-f9a400a970db47da9741d5480308c465"> </div><div class="notion-text notion-block-7c61a9d8623249978727c268df818c31">渲染结果</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-03413843bc064c42a2268f046a47b1c5"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:309px;max-width:100%;flex-direction:column"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fde5ea524-b729-4eea-845e-59eaf20e7149%2Ff06da6f1-a004-466d-9a6a-59d677095faf%2FUntitled.png?table=block&amp;id=03413843-bc06-4c42-a226-8f046a47b1c5&amp;t=03413843-bc06-4c42-a226-8f046a47b1c5&amp;width=309&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-06bd783621e045fe9b1ba4a0cbccac16" data-id="06bd783621e045fe9b1ba4a0cbccac16"><span><div id="06bd783621e045fe9b1ba4a0cbccac16" class="notion-header-anchor"></div><a class="notion-hash-link" href="#06bd783621e045fe9b1ba4a0cbccac16" title="css 相关"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">css 相关</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-37829d309a54425398ccaa37d66d31d7" data-id="37829d309a54425398ccaa37d66d31d7"><span><div id="37829d309a54425398ccaa37d66d31d7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#37829d309a54425398ccaa37d66d31d7" title="scoped 作用域限制"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code">scoped</code> 作用域限制</span></span></h3><div class="notion-text notion-block-c637cce211ca4a1a94aeaf7f7cad24b1">当前样式只在当前文件/组件的作用域下生效</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-d8ffab7889314faa88d7783d9ffad466" data-id="d8ffab7889314faa88d7783d9ffad466"><span><div id="d8ffab7889314faa88d7783d9ffad466" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d8ffab7889314faa88d7783d9ffad466" title=":deep 深度渗透"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>:deep</b></code><b> 深度渗透</b></span></span></h3><div class="notion-text notion-block-9a0b265292cd472397bdb46690973b1e">在<code class="notion-inline-code">scoped</code>的模式下，使用 <code class="notion-inline-code">:deep</code> 来实现父组件的样式影响到子组件。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-458a32790ca640e6837148e5f7b133b6" data-id="458a32790ca640e6837148e5f7b133b6"><span><div id="458a32790ca640e6837148e5f7b133b6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#458a32790ca640e6837148e5f7b133b6" title=":slotted  插槽样式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>:slotted</b></code><b>  插槽样式</b></span></span></h3><div class="notion-text notion-block-6a3d2d66b52d4cdf815ca30d97813a68">默认情况下，作用域的样式是不会影响到子组件，包括<code class="notion-inline-code">&lt;slot/&gt;</code> 的组件，可以使用 <code class="notion-inline-code">:slotted</code> 给插槽的内容添加样式。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-dd66f6682f09446e96243d66acc4f6a0" data-id="dd66f6682f09446e96243d66acc4f6a0"><span><div id="dd66f6682f09446e96243d66acc4f6a0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#dd66f6682f09446e96243d66acc4f6a0" title=":global 全局样式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code"><b>:global</b></code><b> 全局样式</b></span></span></h3><div class="notion-text notion-block-b827e279e03a489cae71f56ba3cbe1a6">样式应用于全局</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-badf54383eae46bc9a9c1d0af6d60424" data-id="badf54383eae46bc9a9c1d0af6d60424"><span><div id="badf54383eae46bc9a9c1d0af6d60424" class="notion-header-anchor"></div><a class="notion-hash-link" href="#badf54383eae46bc9a9c1d0af6d60424" title="混合使用局部样式和全局样式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>混合使用局部样式和全局样式</b></span></span></h3><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-188d2034ff1c4371b2beeeddb8bc433c" data-id="188d2034ff1c4371b2beeeddb8bc433c"><span><div id="188d2034ff1c4371b2beeeddb8bc433c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#188d2034ff1c4371b2beeeddb8bc433c" title="动态样式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>动态样式</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-e14eea0da86e4e6781a1ce2ec5eef1ff"><li>动态<code class="notion-inline-code">style</code>样式</li></ul><ul class="notion-list notion-list-disc notion-block-e588ee959747457e9161f658a8f7304d"><li>动态<code class="notion-inline-code">class</code>样式</li></ul><ul class="notion-list notion-list-disc notion-block-1d281c0b5b5149f9a189d4d6f18019c3"><li>v-bind：将<code class="notion-inline-code">js</code>中的变量的值应用于<code class="notion-inline-code">css</code>中，变量值一般用小写单词表示</li></ul><div class="notion-blank notion-block-deccd551acac498cac3e179b1329d2f9"> </div></main></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法总结]]></title>
        <id>https://tangly1024.com/article/68e8bb51-78ab-478e-9703-59ae37d46ef3</id>
        <link href="https://tangly1024.com/article/68e8bb51-78ab-478e-9703-59ae37d46ef3"/>
        <updated>2023-12-10T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<div id="notion-article" class="mx-auto overflow-hidden "><main class="notion light-mode notion-page notion-block-68e8bb5178ab478e970359ae37d46ef3"><div class="notion-viewport"></div><div class="notion-collection-page-properties"></div><div class="notion-blank notion-block-a4308e1b50c847fa84415db00f9f1375"> </div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-2334825048d74f09bf8ecf8335b1f377"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fde5ea524-b729-4eea-845e-59eaf20e7149%2F5f27b692-10c3-41f8-a87e-d4edbce20e62%2FUntitled.png?table=block&amp;id=23348250-48d7-4f09-bf8e-cf8335b1f377&amp;t=23348250-48d7-4f09-bf8e-cf8335b1f377&amp;width=720&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><div class="notion-blank notion-block-ccee53f3fe2c4dc4aa0724fe66f4bb6f"> </div><div class="notion-blank notion-block-327e4fd362de4f74beb08835da948e4a"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-67ac2c5e169d45f6a49258649286a62a" data-id="67ac2c5e169d45f6a49258649286a62a"><span><div id="67ac2c5e169d45f6a49258649286a62a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#67ac2c5e169d45f6a49258649286a62a" title="时间复杂度"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">时间复杂度</span></span></h2><div class="notion-text notion-block-ebb71a2756cd4c7a8849236c2e27dee6">时间复杂度就是一个函数，用大 O 表示，比如 O(1)、O(n)、O(logN)... 定性描述该算法的运行时间 </div><ul class="notion-list notion-list-disc notion-block-845f424fa346471993a39212990a2b16"><li>O(1) 复杂度</li></ul><div class="notion-text notion-block-73d7573c59a8403bb7f867d3cd1a3a96">因为每次执行代码文件，永远只会执行一次</div><ul class="notion-list notion-list-disc notion-block-d07588bd9b9d4d82b8a903b40365dd43"><li>O(n)</li></ul><ul class="notion-list notion-list-disc notion-block-5abb9b4fd0364508a4a9b1276214a15d"><li>O(n^2)</li></ul><ul class="notion-list notion-list-disc notion-block-196d65ac586c46b4a548b225fa0c2168"><li>O(logN)</li></ul><div class="notion-blank notion-block-39e1279553cd4d239355edc88cad356a"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-176d60c83a274f5ab17c65ac588e9091" data-id="176d60c83a274f5ab17c65ac588e9091"><span><div id="176d60c83a274f5ab17c65ac588e9091" class="notion-header-anchor"></div><a class="notion-hash-link" href="#176d60c83a274f5ab17c65ac588e9091" title="空间复杂度"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>空间复杂度</b></span></span></h2><div class="notion-text notion-block-c63b8d7356ac46349df37e210bd76d03">一个函数，用大 O 表示，比如 O(1) O(n) O(n^2) ... 算法在与运行过程中临时占用存储空间大小的量度</div><ul class="notion-list notion-list-disc notion-block-b480f7800bfa4f1d8d2e83655964ad80"><li>O(1)</li></ul><ul class="notion-list notion-list-disc notion-block-d9c8ae9862d04a1e90cb9d60e9f285d3"><li>O(n)</li></ul><ul class="notion-list notion-list-disc notion-block-5c301f40bf16485686325c146605d149"><li>O(n^2)</li></ul><div class="notion-text notion-block-a907223899984217baa808726048135b"></div><div class="notion-blank notion-block-a5febcfb9aec462fa9c925b1ef7ebb04"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-a4603f29bb7a4f02a199a46a4ae84d5b" data-id="a4603f29bb7a4f02a199a46a4ae84d5b"><span><div id="a4603f29bb7a4f02a199a46a4ae84d5b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a4603f29bb7a4f02a199a46a4ae84d5b" title="数据结构"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">数据结构</span></span></h2><div class="notion-text notion-block-21f74aa0d5834ac68c9009868a1b19be">常见的数据结构：数组、链表、栈、队列、哈希表、树、堆、图。</div><div class="notion-blank notion-block-5b9c5883801643b584c7efaaefd54f36"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-9d9a81b3efc64474ac559de065bff9a5" data-id="9d9a81b3efc64474ac559de065bff9a5"><span><div id="9d9a81b3efc64474ac559de065bff9a5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9d9a81b3efc64474ac559de065bff9a5" title="数组"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">数组</span></span></h3><div class="notion-text notion-block-f3869c2e219e4eeb97d70d39a45f14c6">[数组 array]是一种线性数据结构，其将元素存储在连续的内存空间中。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-f35305d8ea3449f38c9fc99c2167822b" data-id="f35305d8ea3449f38c9fc99c2167822b"><span><div id="f35305d8ea3449f38c9fc99c2167822b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f35305d8ea3449f38c9fc99c2167822b" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h4><div class="notion-text notion-block-3dbc539bef204b799e4af3a4dbeafada">数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</div><ul class="notion-list notion-list-disc notion-block-889a54fff2bc4acc84f6275ef795d60c"><li><b>空间效率高</b>：数组为数据分配了连续的内存块，无须额外的结构开销。</li></ul><ul class="notion-list notion-list-disc notion-block-753f2c176bc441e6bffa2f9d97a03575"><li><b>支持随机访问</b>：数组允许在 O（1） 时间内访问任何元素。</li></ul><ul class="notion-list notion-list-disc notion-block-2029133aa6704a5eb8b2cc9d670b7905"><li><b>缓存局部性</b>：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-ae30c6ce7b38465aada8389c5fe4aad9" data-id="ae30c6ce7b38465aada8389c5fe4aad9"><span><div id="ae30c6ce7b38465aada8389c5fe4aad9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ae30c6ce7b38465aada8389c5fe4aad9" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h4><div class="notion-text notion-block-4c919f830b094b78965071a35313ffcc">连续空间存储是一把双刃剑，其存在以下局限性。</div><ul class="notion-list notion-list-disc notion-block-6b44c060217b415e8adc33fc94d23392"><li><b>插入与删除效率低</b>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li></ul><ul class="notion-list notion-list-disc notion-block-75eca9cc888848abb22e593deb0b5d46"><li><b>长度不可变</b>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li></ul><ul class="notion-list notion-list-disc notion-block-45e71dce2ff4484aa92cfe499528842e"><li><b>空间浪费</b>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-1cc4d861a496413189783a7570d6438d" data-id="1cc4d861a496413189783a7570d6438d"><span><div id="1cc4d861a496413189783a7570d6438d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1cc4d861a496413189783a7570d6438d" title="链表"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">链表</span></span></h3><div class="notion-text notion-block-9995b95986904cc38f3f5550de341146">「链表 linked list」元素存储不连续，通过指针连在一起。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-2922bf16ee684c86830ca3b9d20e3fd3" data-id="2922bf16ee684c86830ca3b9d20e3fd3"><span><div id="2922bf16ee684c86830ca3b9d20e3fd3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2922bf16ee684c86830ca3b9d20e3fd3" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-6835ca076ab342708462f286206570b8"><li><b>动态性</b>：链表的长度可以动态地增加或减少，不需要预先指定大小。这使得链表在需要频繁地插入和删除元素时更加高效，因为它不需要像数组那样进行元素的移动和重新分配内存。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-193b7cf60fb4403da584dbf06c4ed921"><li><b>灵活性</b>：链表可以轻松地实现各种数据结构，如栈、队列和双向链表。通过改变节点之间的指针关系，可以方便地进行插入、删除和反转操作。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-8267ffd5dc5b444aab265710e671d2f4"><li><b>内存管理</b>：链表的节点可以在内存的不同位置分配，不需要连续的内存块。这使得链表更适合处理动态分配和释放内存的场景。</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-ee8a52ae7c2848c7954e096f567af0a7" data-id="ee8a52ae7c2848c7954e096f567af0a7"><span><div id="ee8a52ae7c2848c7954e096f567af0a7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ee8a52ae7c2848c7954e096f567af0a7" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-783893fcb1244017ad36b017e994a846"><li><b>随机访问效率低</b>：链表的节点不像数组那样可以通过索引直接访问，而是需要从头节点开始遍历链表，直到找到目标节点。这使得链表的随机访问效率较低，时间复杂度为 O(n)，其中 n 是链表的长度。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-9f8da98e119e45e498ae22c3eb0bfe49"><li><b>额外的空间开销</b>：链表中每个节点都需要额外的指针来指向下一个节点，这增加了存储空间的开销。相比于数组，链表需要更多的内存空间来存储相同数量的元素。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-c32c41db25c34ec29db8e1af4c04217b"><li><b>不支持直接访问前一个节点</b>：普通的单向链表只能从头节点到尾节点进行遍历，无法直接访问前一个节点。如果需要反向遍历链表或在特定位置插入或删除节点，需要使用双向链表。</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-d53d7a189aa045ef9f096173d4ab31ae" data-id="d53d7a189aa045ef9f096173d4ab31ae"><span><div id="d53d7a189aa045ef9f096173d4ab31ae" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d53d7a189aa045ef9f096173d4ab31ae" title="常见链表类型"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>常见链表类型</b></span></span></h4><ul class="notion-list notion-list-disc notion-block-a3086704767e4b09afb003534694ec29"><li><b>单向链表</b>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 <!-- --> 。</li></ul><ul class="notion-list notion-list-disc notion-block-6fc9448fa6bc470c98738b02bbdcad9e"><li><b>环形链表</b>：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li></ul><ul class="notion-list notion-list-disc notion-block-fd408110abf944e3bea029ed255b7f55"><li><b>双向链表</b>：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li></ul><div class="notion-blank notion-block-409a37894596459ba552a11940a41f7a"> </div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-5c980f62270740188dec076b1470213a" data-id="5c980f62270740188dec076b1470213a"><span><div id="5c980f62270740188dec076b1470213a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5c980f62270740188dec076b1470213a" title="链表 VS 数组"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b><b>链表 VS 数组</b></b></span></span></h4><table class="notion-simple-table notion-block-b2bca53893a04a59a5ac2783a0c62d8f"><tbody><tr class="notion-simple-table-row notion-block-ca7a98baffda46619799d073c1b68a16"><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">ㅤ</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">数组</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">链表</div></td></tr><tr class="notion-simple-table-row notion-block-37780b4f780c4521b2ae6c3ecef6f995"><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">存储方式</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">连续内存空间</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">分散内存空间</div></td></tr><tr class="notion-simple-table-row notion-block-cee2a684225347a2a8eabe1723e1cce2"><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">容量扩展</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">长度不可变</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">可灵活扩展</div></td></tr><tr class="notion-simple-table-row notion-block-386425fd6b82420fb8115d54ef7ae5ee"><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">内存效率</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">元素占用内存少、但可能浪费空间</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">元素占用内存多</div></td></tr><tr class="notion-simple-table-row notion-block-06a90ce738d749f0a200f58b22039129"><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">访问元素</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">O(1)</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">O(n)</div></td></tr><tr class="notion-simple-table-row notion-block-f04fcad26d0e458794cb3c7f6db1038d"><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">添加元素</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">O(n)</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">O(1)</div></td></tr><tr class="notion-simple-table-row notion-block-d3c504c970304820bbc5eb7e20f60149"><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">删除元素</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">O(n)</div></td><td class="" style="width:232.66668701171875px"><div class="notion-simple-table-cell">O(1)</div></td></tr></tbody></table><ul class="notion-list notion-list-disc notion-block-a541470a639240538057517d2352e387"><li>数组：增删非首尾元素时往往需要移动元素。</li></ul><ul class="notion-list notion-list-disc notion-block-028b4268dc7c432d89135b7a753b1e33"><li>链表：增删非首尾元素，不需要移动元素，只需要更改 next 的指向即可。</li></ul><div class="notion-text notion-block-0fb4dd433a8b466787b62f2372f094fa">JavaScript 中可以用 Object 模拟链表</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f5b1ba7ca09a40a596d35b046e261a26" data-id="f5b1ba7ca09a40a596d35b046e261a26"><span><div id="f5b1ba7ca09a40a596d35b046e261a26" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f5b1ba7ca09a40a596d35b046e261a26" title="栈"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">栈</span></span></h3><div class="notion-text notion-block-b8ad238822594350a6a77e15c2b752c9">「栈 stack」是一种遵循先入后出的逻辑的线性数据结构。栈遵循先入后出的原则，因此我们只能在栈顶添加或删除元素。</div><div class="notion-text notion-block-3a735c6c15624cf79bda242430b1e4a2">数组和链表都可以在任意位置添加和删除元素，<b>因此栈可以视为一种受限制的数组或链表</b>。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-22660791992745f8b3e3a10f796f6df1" data-id="22660791992745f8b3e3a10f796f6df1"><span><div id="22660791992745f8b3e3a10f796f6df1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#22660791992745f8b3e3a10f796f6df1" title="典型应用"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>典型应用</b></span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-c98cc3fcc0cc4caba16364cc6724d447"><li>软件中的撤销与反撤销</li></ol><div class="notion-blank notion-block-e56943b3fc074e63b03151b1e9249bcd"> </div><details class="notion-toggle notion-block-a52fdfe99bff4e35b6cfe757f663f876"><summary><b>撤销（undo）和反撤销（redo）具体是如何实现的？</b></summary><div><div class="notion-text notion-block-aca46e3d179144598e9f23c0d20ea47c">使用两个堆栈，栈 <code class="notion-inline-code">A</code> 用于撤销，栈 <code class="notion-inline-code">B</code> 用于反撤销。</div><ol start="1" class="notion-list notion-list-numbered notion-block-0e6e91699e5149da9119c774091ca644"><li>每当用户执行一个操作，将这个操作压入栈 <code class="notion-inline-code">A</code> ，并清空栈 <code class="notion-inline-code">B</code> 。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-65001cbfa10e49739769ef05642118a8"><li>当用户执行“撤销”时，从栈 <code class="notion-inline-code">A</code> 中弹出最近的操作，并将其压入栈 <code class="notion-inline-code">B</code> 。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-0d2b634d39ab475998b45bc87d9ee6d0"><li>当用户执行“反撤销”时，从栈 <code class="notion-inline-code">B</code> 中弹出最近的操作，并将其压入栈 <code class="notion-inline-code">A</code> 。</li></ol></div></details><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-c60dfc63d66e40718d133aac4b1c693d" data-id="c60dfc63d66e40718d133aac4b1c693d"><span><div id="c60dfc63d66e40718d133aac4b1c693d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c60dfc63d66e40718d133aac4b1c693d" title="队列"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">队列</span></span></h3><div class="notion-text notion-block-cbdd779b8d80425e9fc828e216f96962">「队列 queue」是一种遵循先入先出规则的线性数据结构。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-e9fe1b4cbc39418189cc9d5127a355b6" data-id="e9fe1b4cbc39418189cc9d5127a355b6"><span><div id="e9fe1b4cbc39418189cc9d5127a355b6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e9fe1b4cbc39418189cc9d5127a355b6" title="典型应用"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">典型应用</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-d84c56c96f42488db96dda04411b001d"><li><b>各类待办事项</b>。任何需要实现“先来后到”功能的场景，例如排队取号，淘宝订单，出餐队列</li></ol><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-6721d416d1eb4b40bff8ee9c6cd874fe" data-id="6721d416d1eb4b40bff8ee9c6cd874fe"><span><div id="6721d416d1eb4b40bff8ee9c6cd874fe" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6721d416d1eb4b40bff8ee9c6cd874fe" title="哈希表"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">哈希表</span></span></h3><div class="notion-text notion-block-b48e3a3ee80f476f90e6c89391c889c8">「哈希表 hash table」，又称「散列表」，其通过建立键 key 与值 value 之间的映射，实现高效的元素查询。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-59768805b51a46d39ec5dae35c35b9cb" data-id="59768805b51a46d39ec5dae35c35b9cb"><span><div id="59768805b51a46d39ec5dae35c35b9cb" class="notion-header-anchor"></div><a class="notion-hash-link" href="#59768805b51a46d39ec5dae35c35b9cb" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h4><ul class="notion-list notion-list-disc notion-block-f17c5552703449828486899851f97a30"><li><b>高效的增删改查</b>，哈希表的增删改查操作能够在O(1)时间完成。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-8b14aeddfb7b40bdbd5d1a4fb9d07e09" data-id="8b14aeddfb7b40bdbd5d1a4fb9d07e09"><span><div id="8b14aeddfb7b40bdbd5d1a4fb9d07e09" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8b14aeddfb7b40bdbd5d1a4fb9d07e09" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h4><ul class="notion-list notion-list-disc notion-block-ff05fa336ebc450486d24340e75a2b74"><li>冲突的处理：由于哈希函数的映射并非完全唯一，不同的键可能会映射到相同的存储桶中，这就是冲突。</li></ul><ul class="notion-list notion-list-disc notion-block-b31bf80fdf4e4817b06d585a8b724475"><li>内存消耗：为了存储哈希表的键和值，需要分配额外的内存空间。在存储大量数据时，哈希表可能占用较多的内存。</li></ul><ul class="notion-list notion-list-disc notion-block-a4a57e8f6d5941769514e15077f34482"><li>遍历顺序不确定：哈希表中的元素没有固定的顺序。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-0d4d4c2a7d41459e8244b4ffc5ce6d07" data-id="0d4d4c2a7d41459e8244b4ffc5ce6d07"><span><div id="0d4d4c2a7d41459e8244b4ffc5ce6d07" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0d4d4c2a7d41459e8244b4ffc5ce6d07" title="典型应用"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">典型应用</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-22f885cbf4964e55ba5c9bd213def015"><li>数据存储和检索，例如数据库</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-8229e48fee4e4c04ba433a6c1b52f741"><li>唯一性检查。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-bc02f7be01604d0995a6132a11a00c00"><li>缓存实现。</li></ol><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e0c14d5257ff410a925e735c1876819d" data-id="e0c14d5257ff410a925e735c1876819d"><span><div id="e0c14d5257ff410a925e735c1876819d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e0c14d5257ff410a925e735c1876819d" title="二叉树"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>二叉树</b></span></span></h3><div class="notion-text notion-block-c31018aae6be45569d21740fb82024b3">[二叉树 binary tree」是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。</div><div class="notion-text notion-block-5f5d40d7efcb42b8800ea8583e48f5cd"><b>二叉树的所有问题，就是让你在前中后序位置注入逻辑代码。</b></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-878b6fd61ef347a09f380c0cee2e17a3" data-id="878b6fd61ef347a09f380c0cee2e17a3"><span><div id="878b6fd61ef347a09f380c0cee2e17a3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#878b6fd61ef347a09f380c0cee2e17a3" title="类型"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">类型</span></span></h4><ul class="notion-list notion-list-disc notion-block-d07e5c5f7f4c445dbe028a6bf2905161"><li><b><b>完美二叉树</b></b></li></ul><div class="notion-text notion-block-a03e0cc1ea1743dcb86f43b145070ca2">即所有层的节点都被完全填满。</div><ul class="notion-list notion-list-disc notion-block-69f92aa6a9544869836670a9cc24bfb7"><li><b><b>完全二叉树</b></b></li></ul><div class="notion-text notion-block-786b793362bd4ca2bfafb9f6de937ac5">只有最底层的节点未被填满，且最底层节点尽量靠左填充。</div><ul class="notion-list notion-list-disc notion-block-76f4d4a77a2948d6bd9de567fba26bcb"><li><b><b>平衡二叉树</b></b></li></ul><div class="notion-text notion-block-5bb7db944a114224a832aff968a7661b">任意节点的左子树和右子树的高度之差的绝对值不超过 1 。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-f4ffb057cce44a6bbde39c450c1d1b8e" data-id="f4ffb057cce44a6bbde39c450c1d1b8e"><span><div id="f4ffb057cce44a6bbde39c450c1d1b8e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f4ffb057cce44a6bbde39c450c1d1b8e" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h4><div class="notion-text notion-block-7ff497dad24344cfb12cfc89d5aec11b">二叉树的数组表示主要有以下优点。</div><ul class="notion-list notion-list-disc notion-block-d252c729db234b04bfa629720a8aec5f"><li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li></ul><ul class="notion-list notion-list-disc notion-block-a61d85a09a634ea0b55cc343c343f8bc"><li>不需要存储指针，比较节省空间。</li></ul><ul class="notion-list notion-list-disc notion-block-298f6456c7474f298be5a6d8194a419d"><li>允许随机访问节点。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-3cf33172e23345f4879369e5a283aeb6" data-id="3cf33172e23345f4879369e5a283aeb6"><span><div id="3cf33172e23345f4879369e5a283aeb6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3cf33172e23345f4879369e5a283aeb6" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h4><ul class="notion-list notion-list-disc notion-block-de9c0022d09c4653bd0234e25a5b0102"><li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li></ul><ul class="notion-list notion-list-disc notion-block-1f39a5081bb04fd2b12956c95e6ebb45"><li>增删节点需要通过数组插入与删除操作实现，效率较低。</li></ul><ul class="notion-list notion-list-disc notion-block-adf0ab5d3b4e450d818c156a8d89451d"><li>当二叉树中存在大量 NONE 时，数组中包含的节点数据比重较低，空间利用率较低。</li></ul><div class="notion-blank notion-block-b45eb92e41354b23b00306fdc8dbdffd"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3c9483c083f64d109813cc28251e4ae4" data-id="3c9483c083f64d109813cc28251e4ae4"><span><div id="3c9483c083f64d109813cc28251e4ae4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3c9483c083f64d109813cc28251e4ae4" title="堆"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">堆</span></span></h3><div class="notion-text notion-block-f06774b449364688aa57d8d0c99d2b9b">「堆 heap」是一种满足特定条件的完全二叉树，主要可分为两种类型:</div><ul class="notion-list notion-list-disc notion-block-eccd65a8088044aa87778c5c3c217432"><li>「大顶堆 max heap」：任意节点的值 ≥其子节点的值。</li></ul><ul class="notion-list notion-list-disc notion-block-a1b8756594454858b5b86957d29f07da"><li>「小顶堆 min heap」：任意节点的值  ≤其子节点的值。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-8cc1abc6f29f4e45b4fd52eb2870d935" data-id="8cc1abc6f29f4e45b4fd52eb2870d935"><span><div id="8cc1abc6f29f4e45b4fd52eb2870d935" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8cc1abc6f29f4e45b4fd52eb2870d935" title="典型应用"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">典型应用</span></span></h4><ul class="notion-list notion-list-disc notion-block-d6c7b93af72540eebe3f0d03552afbfd"><li><b>优先队列</b>：堆通常作为实现优先队列的首选数据结构，其入队和出队操作的时间复杂度均为 <!-- --> ，而建队操作为 <!-- --> ，这些操作都非常高效。</li></ul><ul class="notion-list notion-list-disc notion-block-ae9657b83af94a45bc43f24eb8003b42"><li><b>堆排序</b>：给定一组数据，我们可以用它们建立一个堆，然后不断地执行元素出堆操作，从而得到有序数据。然而，我们通常会使用一种更优雅的方式实现堆排序，详见“堆排序”章节。</li></ul><ul class="notion-list notion-list-disc notion-block-5a587ff14cc6492eb2a5432903762ff2"><li><b>获取最大的K个元素</b>：这是一个经典的算法问题，同时也是一种典型应用，例如选择热度前 10 的新闻作为微博热搜，选取销量前 10 的商品等。</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-707ed3909c0f456da5b78f777006cbac" data-id="707ed3909c0f456da5b78f777006cbac"><span><div id="707ed3909c0f456da5b78f777006cbac" class="notion-header-anchor"></div><a class="notion-hash-link" href="#707ed3909c0f456da5b78f777006cbac" title="图"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">图</span></span></h3><div class="notion-text notion-block-99cbf962841a4a9bb10e15da5344789d">「图 graph」是一种非线性数据结构，图由顶点和边组成，可以表示为一组顶点和一组边构成的集合。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-04ccd85610de4268a930d31199821be7" data-id="04ccd85610de4268a930d31199821be7"><span><div id="04ccd85610de4268a930d31199821be7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#04ccd85610de4268a930d31199821be7" title="算法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">算法</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-4bee23c3d6234708aae9781e9ad4bd44" data-id="4bee23c3d6234708aae9781e9ad4bd44"><span><div id="4bee23c3d6234708aae9781e9ad4bd44" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4bee23c3d6234708aae9781e9ad4bd44" title="二分查找"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>二分查找</b></span></span></h3><div class="notion-text notion-block-9be4507c1bf84ea082ddd05693abf64a">思路：它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-357fa869d607400792a30e57e184d477" data-id="357fa869d607400792a30e57e184d477"><span><div id="357fa869d607400792a30e57e184d477" class="notion-header-anchor"></div><a class="notion-hash-link" href="#357fa869d607400792a30e57e184d477" title="排序"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">排序</span></span></h3><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-331cd6103af34453ae9f20b9d0b98448" data-id="331cd6103af34453ae9f20b9d0b98448"><span><div id="331cd6103af34453ae9f20b9d0b98448" class="notion-header-anchor"></div><a class="notion-hash-link" href="#331cd6103af34453ae9f20b9d0b98448" title="选择排序"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">选择排序</span></span></h3><div class="notion-text notion-block-c2cc79fc203b4f539d94d55cf260d645">找到队列中的最小值并 将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-c0372b14a2fe46cf9d656349c362bff5" data-id="c0372b14a2fe46cf9d656349c362bff5"><span><div id="c0372b14a2fe46cf9d656349c362bff5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c0372b14a2fe46cf9d656349c362bff5" title="冒泡排序"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">冒泡排序</span></span></h4><div class="notion-text notion-block-46898ee7951f4ae6b900658e76ca7023">开启一个循环，每轮从未排序区间首位开始比较两个相邻的项，如果第一个比第二个大，则交换它们。这样每轮循环都会找到一个最大的数在最后。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-f7758e4575e049d9bbf43c70605ce9f6" data-id="f7758e4575e049d9bbf43c70605ce9f6"><span><div id="f7758e4575e049d9bbf43c70605ce9f6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f7758e4575e049d9bbf43c70605ce9f6" title="插入排序"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">插入排序</span></span></h4><div class="notion-text notion-block-91e22c5d3e1344358a0ab51f8f596ec4">将第一个元素视为有序序列，剩下的元素作为未排序序列。从头到尾扫描未排序序列，将当前元素插入到有序序列的合适位置。如果待插入的元素与有序序列中的某个元素相等或大于，则将待插入元素插入到相等元素的后面。重复循环，直到未排序序列为空。</div><div class="notion-text notion-block-62a632a1e7b948279dc4ec312c62977f">这个过程类似于玩斗地主时抓牌的过程，将每张新抓的牌与手中已有的牌进行比较，找到合适的位置插入。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-b00ea57f8de2438982389e34f2d8dd7e" data-id="b00ea57f8de2438982389e34f2d8dd7e"><span><div id="b00ea57f8de2438982389e34f2d8dd7e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b00ea57f8de2438982389e34f2d8dd7e" title="快速排序"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">快速排序</span></span></h4><div class="notion-text notion-block-2cf905e039fb4ab29ea58bc74409b718">采用分治的思想来进行排序。</div><div class="notion-text notion-block-4d919ebda23b49eab2e88ae2773f94ab">快速排序的基本思想是选择一个基准元素，通过一趟排序将待排序的序列分割成独立的两部分，其中一部分的所有元素都小于基准元素，另一部分的所有元素都大于基准元素，然后对这两部分分别进行递归排序，最终得到一个有序序列。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-0976ff5c4cdc43a99acff032a653c416" data-id="0976ff5c4cdc43a99acff032a653c416"><span><div id="0976ff5c4cdc43a99acff032a653c416" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0976ff5c4cdc43a99acff032a653c416" title="归并排序"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">归并排序</span></span></h4><div class="notion-text notion-block-7a11f1608cd24eeba6b674f128a279d1">采用分治的思想来进行排序。</div><div class="notion-text notion-block-bc8b6c62717d466aaf4f2ef02349f95d">将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 时间复杂度为 O(n log n)。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-375b8e95cb9f414abda1a264b484479d" data-id="375b8e95cb9f414abda1a264b484479d"><span><div id="375b8e95cb9f414abda1a264b484479d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#375b8e95cb9f414abda1a264b484479d" title="堆排序"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">堆排序</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-7c77aa0041ac4a738ef83648f1dc59f7"><li>输入数组并建立大顶堆。完成后，最大元素位于堆顶。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-78a4f7e2ceb24f098955359806940299"><li>1. 从堆顶元素开始，从顶到底执行堆化操作（Sift Down）。完成堆化后，堆的性质得到修复。</li></ol><div class="notion-blank notion-block-55ab7c0501cf4d1a97b10b1aaf4b8ada"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-2a56d6078c014a358c1cb7a2f4441be5" data-id="2a56d6078c014a358c1cb7a2f4441be5"><span><div id="2a56d6078c014a358c1cb7a2f4441be5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2a56d6078c014a358c1cb7a2f4441be5" title="二叉树"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>二叉树</b></span></span></h3><div class="notion-text notion-block-280ab578a3574ed4a0a9be6984b45485"><b>二叉树的所有问题，就是让你在前中后序位置注入逻辑代码。</b></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-a2ab923107e74770a7eef66d05a8983b" data-id="a2ab923107e74770a7eef66d05a8983b"><span><div id="a2ab923107e74770a7eef66d05a8983b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a2ab923107e74770a7eef66d05a8983b" title="使用场景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">使用场景</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-eb9b9e3a906c462ca29fa994e993a55a"><li>求根到叶子节点数字之和</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-feb854521d1546ad848c8944fef83652"><li>平衡二叉树</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-f11665cf4c2f4c8e917a1a2ac1048635" data-id="f11665cf4c2f4c8e917a1a2ac1048635"><span><div id="f11665cf4c2f4c8e917a1a2ac1048635" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f11665cf4c2f4c8e917a1a2ac1048635" title="解题思路"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">解题思路</span></span></h4><div class="notion-text notion-block-707d4b9c191b497e918a4c233892324e"><b>1、是否可以通过遍历一遍二叉树得到答案</b>？如果可以，用一个 <code class="notion-inline-code">traverse</code> 函数配合外部变量来实现。</div><div class="notion-text notion-block-1928084d5455445b864f6e1e17471072"><b>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</b>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</div><div class="notion-text notion-block-2f018b6ab24849d19e66d7206d148b61"><b>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</b></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-db6e5a549ab045b0b6b41fd7b5934a28" data-id="db6e5a549ab045b0b6b41fd7b5934a28"><span><div id="db6e5a549ab045b0b6b41fd7b5934a28" class="notion-header-anchor"></div><a class="notion-hash-link" href="#db6e5a549ab045b0b6b41fd7b5934a28" title="四种遍历方式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>四种遍历方式</b></span></span></h4><div class="notion-text notion-block-1570b150e9834d388bef0ac3b8e959a8"> <b>前序遍历</b></div><div class="notion-text notion-block-09c4e57832254ccb874b939001da86d4">根结点 ---&gt; 左节点 ---&gt; 右节点</div><div class="notion-text notion-block-3ed432120a1941599b67dac8ba319644"><b>中序遍历</b></div><div class="notion-text notion-block-1d10d6e16e6d493d9772b05bac9b046c">左子树---&gt; 根结点 ---&gt; 右子树</div><div class="notion-text notion-block-bcf4be1ca4c84ca3ad353e09ecc6d245"><b>后序遍历</b></div><div class="notion-text notion-block-a1007fdb6ec74e7790364a3a3ce4d222">左子树 ---&gt; 右子树 ---&gt; 根结点</div><div class="notion-text notion-block-9201c5df6aa24c8d83896b95d55e06b8"><b>层序遍历</b></div><div class="notion-text notion-block-6acf8f7c7c0d4c069df16943739af5a0">从上到下，从左到右访问。</div><div class="notion-text notion-block-1aee8f6a22244f1283e0bc9dcec778a0">前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3a44b7f52e98440b9e9a2f16af1d7652" data-id="3a44b7f52e98440b9e9a2f16af1d7652"><span><div id="3a44b7f52e98440b9e9a2f16af1d7652" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3a44b7f52e98440b9e9a2f16af1d7652" title="双指针"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>双指针</b></span></span></h3><div class="notion-text notion-block-9de83714a58b4fc187a03aaeaa1a663e">数组和链表算法主要都是使用双指针，双指针分为两类：</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-005fccf5deb2408cbdadf7f40b39fcf6" data-id="005fccf5deb2408cbdadf7f40b39fcf6"><span><div id="005fccf5deb2408cbdadf7f40b39fcf6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#005fccf5deb2408cbdadf7f40b39fcf6" title="应用场景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">应用场景</span></span></h4><ul class="notion-list notion-list-disc notion-block-9ed724ab0e904ac2a43ebdc641680f9d"><li>分发饼干</li></ul><ul class="notion-list notion-list-disc notion-block-f1615344790b4e3c92ffbeee169c7771"><li>验证回文串</li></ul><ul class="notion-list notion-list-disc notion-block-0b32ce4ea20d4b6c83ea72d65d71e347"><li>移动零</li></ul><ul class="notion-list notion-list-disc notion-block-c98f4686c27b404182da998b087218a6"><li>合并两个有序数组</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-2fd8a9e211c44bde86733144bd8a8a7e" data-id="2fd8a9e211c44bde86733144bd8a8a7e"><span><div id="2fd8a9e211c44bde86733144bd8a8a7e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2fd8a9e211c44bde86733144bd8a8a7e" title="左右指针"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>左右指针</b></span></span></h4><div class="notion-text notion-block-d3939480a2604101b411c10301d8830d">两个指针相向而行或相背而行。</div><div class="notion-text notion-block-2f9e8dfe273f405986ef72b07aaa677d">使用场景：</div><ol start="1" class="notion-list notion-list-numbered notion-block-fbfcea3f0f4743c9a5a55e04e1645a14"><li>二分查找</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-cdd29fb7b28248b2b1f748f84c5762b9"><li>两数之和</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-ea005f9987ca4540a146424fe042876e"><li>反转数组</li></ol><ol start="4" class="notion-list notion-list-numbered notion-block-525ddb7aa0b74990957c8c9d5170541c"><li>回文判断</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-91e642a32d6c4d0c8ebdf906a154a4f2" data-id="91e642a32d6c4d0c8ebdf906a154a4f2"><span><div id="91e642a32d6c4d0c8ebdf906a154a4f2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#91e642a32d6c4d0c8ebdf906a154a4f2" title="快慢指针"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>快慢指针</b></span></span></h4><div class="notion-text notion-block-295e4c8649034ca7985d29d6def3b007">两个指针同向而行，一快一慢。</div><div class="notion-text notion-block-3e5a59b92c5f4cd99c70c7d61ce63a49">使用场景：</div><ol start="1" class="notion-list notion-list-numbered notion-block-11680aff1d024003abfc6a26d5fcf5ae"><li>涉及到第n个</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-db0f6626395c4ce7ac4d8f62a5b8f9ba"><li>涉及到原地修改的，例如数组去重，数组移除元素</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-ccf1ae8b060442779fc5b975e76d8ede"><li>滑动窗口算法</li></ol><ol start="4" class="notion-list notion-list-numbered notion-block-5ce2f87ff39c4cc3995e85b929dbb4c2"><li>二分查找</li></ol><ol start="5" class="notion-list notion-list-numbered notion-block-9f4cd21475a745899b0cb0f5bbaae6b4"><li>两数之和</li></ol><div class="notion-blank notion-block-b110d72137644079b001537d8d9035cc"> </div><div class="notion-blank notion-block-8b365b9ac0b94748912c1a37c0ab92bb"> </div><div class="notion-blank notion-block-ba477a54842542afb597925def55404b"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-20a293c6db324fce924be1fe4bd755a2" data-id="20a293c6db324fce924be1fe4bd755a2"><span><div id="20a293c6db324fce924be1fe4bd755a2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#20a293c6db324fce924be1fe4bd755a2" title="深度优先搜索（DFS）、广度优先搜索（BFS）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">深度优先搜索（DFS）、广度优先搜索（BFS）</span></span></h3><div class="notion-blank notion-block-8f956184b65e404dada854a1c8b1bae0"> </div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-e5a54d288e724b3499ef920db3358d95" data-id="e5a54d288e724b3499ef920db3358d95"><span><div id="e5a54d288e724b3499ef920db3358d95" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e5a54d288e724b3499ef920db3358d95" title="BFS"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>BFS</b></span></span></h4><div class="notion-text notion-block-049be2330bef460186aa814f4f98eb00">本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-d0410218432e4da88eb94f441dfcffd7" data-id="d0410218432e4da88eb94f441dfcffd7"><span><div id="d0410218432e4da88eb94f441dfcffd7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d0410218432e4da88eb94f441dfcffd7" title="BFS 与DFS 区别"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>BFS 与DFS 区别</b></span></span></h4><div class="notion-text notion-block-d99ba2a2c8df4254a23a5ac07309e7a4"><b>方式：</b></div><div class="notion-text notion-block-a2e1c7c778124095bed3c97368d33913">DFS是深度遍历，通过递归，遍历所有路径才能找到。</div><div class="notion-text notion-block-a37024ddc5a9422798daf16f942fd811">BFS是广度遍历，通过队列，遍历当前路径。不满足条件，才会进行下一层路径遍历，所以BFS 找到的路径一定是最短的。</div><div class="notion-text notion-block-cb9a3bf12a9742e98a708228e8d32569"><b>空间复杂度：</b></div><div class="notion-text notion-block-e5505533f05f40e1a18eaa72e7b851e0">DFS遍历使用递归，最坏情况就是树的高度，也就是 <code class="notion-inline-code">O(logN)</code>，空间复杂度低。</div><div class="notion-text notion-block-8bcba6d757d64a7f8d30114a758a584c">BFS遍历使用队列，队列中需要存储一层的所有节点，也就是 <code class="notion-inline-code">O(N)</code>，空间复杂度高。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-2be195863e254a7daab1d16b01ec0e24" data-id="2be195863e254a7daab1d16b01ec0e24"><span><div id="2be195863e254a7daab1d16b01ec0e24" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2be195863e254a7daab1d16b01ec0e24" title="BFS使用场景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">BFS<b>使用场景</b></span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-ffa45bcced254dd68c5184e629f90845"><li>层序遍历</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-de9a646e5bea47e39e9fe388d60dc5f3"><li>找最短路径</li></ol><div class="notion-text notion-block-6f3731a332de4a1eaaf0233be9f4382e">解题思路：</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-0ff4eee938e84e54be710b47e5e98fa7" data-id="0ff4eee938e84e54be710b47e5e98fa7"><span><div id="0ff4eee938e84e54be710b47e5e98fa7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0ff4eee938e84e54be710b47e5e98fa7" title="双向BFS优化"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>双向BFS优化</b></span></span></h4><div class="notion-text notion-block-9e60380407484a50b30d600004519c30"><b>原理</b></div><div class="notion-text notion-block-76cde9c9960f4fac809118e404789d33">传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 <code class="notion-inline-code">target</code>；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。</div><div class="notion-text notion-block-4b6e4d8debfc4603acb6f5fc9a08254a"><b>局限</b></div><div class="notion-text notion-block-03980a2f70e54fae8525785819d2edfa">必须知道终点在哪里。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3fde1ef165474f30bd50f40ceced0d97" data-id="3fde1ef165474f30bd50f40ceced0d97"><span><div id="3fde1ef165474f30bd50f40ceced0d97" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3fde1ef165474f30bd50f40ceced0d97" title="滑动窗口"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>滑动窗口</b></span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-9778ff3ba527491aa584acd21d0d4002" data-id="9778ff3ba527491aa584acd21d0d4002"><span><div id="9778ff3ba527491aa584acd21d0d4002" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9778ff3ba527491aa584acd21d0d4002" title="解题思路"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">解题思路</span></span></h4><ul class="notion-list notion-list-disc notion-block-3918ff016c38403ab39fc4c2989e97f6"><li>定义左右指针</li></ul><ul class="notion-list notion-list-disc notion-block-8565f58b67534a6aaae8663d20053234"><li>先移动右指针，</li></ul><ul class="notion-list notion-list-disc notion-block-ea77cee40ff144778ecc445c1fff609d"><li>每当满足收缩条件时，就移动左指针，</li></ul><ul class="notion-list notion-list-disc notion-block-a58388367e4241c286f6171324ce3073"><li>直到不满足条件后，再重新开始移动右指针。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-f2b8f58937a64a1fb57673e66582a922" data-id="f2b8f58937a64a1fb57673e66582a922"><span><div id="f2b8f58937a64a1fb57673e66582a922" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f2b8f58937a64a1fb57673e66582a922" title="使用场景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">使用场景</span></span></h4><ul class="notion-list notion-list-disc notion-block-2bd7bcd4860b4f3aaf382bc0ef9b0e85"><li>查找子串</li></ul><ul class="notion-list notion-list-disc notion-block-e57c7dc14b55456abfb6eff777243f4f"><li>长度最小的子数组</li></ul><div class="notion-text notion-block-19b64e4234e749349269c845ddb74771">思路</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-1340e8192b36495e9f70ea78e5b139b9" data-id="1340e8192b36495e9f70ea78e5b139b9"><span><div id="1340e8192b36495e9f70ea78e5b139b9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1340e8192b36495e9f70ea78e5b139b9" title="动态规划"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>动态规划</b></span></span></h3><div class="notion-text notion-block-6cc5ea645bef4297952ea34dba652d97">它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。</div><div class="notion-text notion-block-2ecbf665a4d146969cf74528cebf4010">最典型的应用：斐波那契数列</div><div class="notion-text notion-block-f95464fa23bb48cba7540b8eca3160a0">0 1 1 2 3 5 例如第三个 等于 第一个 + 第二个 定义子问题：F(n) = F(n - 1) + F(n - 2) 反复执行：从 2 循环到 n ，执行上面的公式。</div><div class="notion-text notion-block-42b18926c4124b6484e5e8029f6fc53b"><b>动态规划问题都是斐波那契数列的变种。</b></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-c56545a747fa419ba44b9c66cd1d96ca" data-id="c56545a747fa419ba44b9c66cd1d96ca"><span><div id="c56545a747fa419ba44b9c66cd1d96ca" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c56545a747fa419ba44b9c66cd1d96ca" title="应用场景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">应用场景</span></span></h3><ul class="notion-list notion-list-disc notion-block-f5d924ed3b1043faa43ca1885f58ac04"><li>爬楼梯</li></ul><ul class="notion-list notion-list-disc notion-block-7708e2a2cb0049718d939f65a9f06afc"><li>找钱</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-636db30d18cd452293b5cfd090ae39b1" data-id="636db30d18cd452293b5cfd090ae39b1"><span><div id="636db30d18cd452293b5cfd090ae39b1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#636db30d18cd452293b5cfd090ae39b1" title="动态规划 VS 分而治之"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>动态规划 VS 分而治之</b></span></span></h4><ul class="notion-list notion-list-disc notion-block-624dfd309b8f40f3b3856904fbdd6877"><li>分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。</li></ul><ul class="notion-list notion-list-disc notion-block-7976a3c6428042e7b861252c95c6103e"><li>动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。</li></ul><ul class="notion-list notion-list-disc notion-block-a765c9db932b4d78991dd0f0fda9f969"><li>回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。</li></ul><div class="notion-text notion-block-017a1e02912e440682b4f060743bc3a0">实际上，动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-ab91fd2548d94ca9a6f2b49d094dbd13" href="https://lq782655835.github.io/blogs/js/data-structure.html"><div><div class="notion-bookmark-title">数据结构 | springleo&#x27;s blog</div><div class="notion-bookmark-description">团队规范</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lq782655835.github.io/blogs/favicon.ico?t=ab91fd25-48d9-4ca9-a6f2-b49d094dbd13" alt="数据结构 | springleo&#x27;s blog" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://lq782655835.github.io/blogs/js/data-structure.html</div></div></div></a></div><div class="notion-blank notion-block-2e74f94a4bcb4fa2ad9a31bb5652bc35"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-0da42d62f44c4c83ba41c79685df9110" data-id="0da42d62f44c4c83ba41c79685df9110"><span><div id="0da42d62f44c4c83ba41c79685df9110" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0da42d62f44c4c83ba41c79685df9110" title="贪心"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">贪心</span></span></h3><div class="notion-text notion-block-af845641b1de4ed2bcd01f6bd2bfd9fb">其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。</div><div class="notion-text notion-block-04fff7ac9dde444a98cf87706612ee88">比如找零钱，你面前放着 100 张人民币，<b>我们贪心地选择不大于且最接近它的硬币</b>，不断循环该步骤，直至凑出目标金额为止。你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</div><div class="notion-blank notion-block-f5f55bf21fba4f9a9d40c0a9a4ab23ef"> </div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-ca7b61be07434e1f89ddc088d9904a61" data-id="ca7b61be07434e1f89ddc088d9904a61"><span><div id="ca7b61be07434e1f89ddc088d9904a61" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ca7b61be07434e1f89ddc088d9904a61" title="应用场景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">应用场景</span></span></h4><ul class="notion-list notion-list-disc notion-block-09f9d7f459434473b4ee5c164ee56583"><li><b>硬币找零问题</b>：在某些硬币组合下，贪心算法总是可以得到最优解。</li></ul><ul class="notion-list notion-list-disc notion-block-370f9f36504145e6a7c68d4abffebe31"><li><b>区间调度问题</b>：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。</li></ul><ul class="notion-list notion-list-disc notion-block-228b4e7b7c634801837b90c539fcbae5"><li><b>分数背包问题</b>：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。</li></ul><ul class="notion-list notion-list-disc notion-block-75d18b67751146ad8d301c71a3d23c6c"><li><b>股票买卖问题</b>：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。</li></ul><div class="notion-blank notion-block-c3395b4e12744492999df791ca67b25a"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-74379d5acedf4ee3b01a8810690acff0" data-id="74379d5acedf4ee3b01a8810690acff0"><span><div id="74379d5acedf4ee3b01a8810690acff0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#74379d5acedf4ee3b01a8810690acff0" title="分治"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">分治</span></span></h3><div class="notion-text notion-block-d9ddded53e9448d5b92e8d18e861a777"><b>它将一个问题分成多个和原问题类似的小问题，递归解决小问题，再将结果合并以解决原来的问题。</b></div><div class="notion-text notion-block-1e319fd27ad042649c4ec483a954020e">包括分（划分）和治（合并）两个阶段，通常基于递归实现。</div><ol start="1" class="notion-list notion-list-numbered notion-block-90acd239d7b54acfab01a8c6d5939962"><li><b>分（划分阶段）</b>：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-2da058f9f8524edbbac52926b36e61ee"><li><b>治（合并阶段）</b>：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-b0a1997cf7dd45e5ac4d8a8c0e424a30" data-id="b0a1997cf7dd45e5ac4d8a8c0e424a30"><span><div id="b0a1997cf7dd45e5ac4d8a8c0e424a30" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b0a1997cf7dd45e5ac4d8a8c0e424a30" title="使用场景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>使用场景</b></span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-4110fd6b7b044935950bc9d1b2e63986"><li>归并排序 分：把数组从中间一份为二。合：合并两个有序子数组。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-b27bfc78a2c343189e54b3a158441abd"><li>快速排序 分：选基准数，分成两个数组。 合：对两个子数组进行合并。</li></ol><div class="notion-blank notion-block-c09edcf6356c411d8014f755b7890573"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-be85cd642bbe4535990230bd3049662e" data-id="be85cd642bbe4535990230bd3049662e"><span><div id="be85cd642bbe4535990230bd3049662e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#be85cd642bbe4535990230bd3049662e" title="回溯"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">回溯</span></span></h3><div class="notion-text notion-block-fc6a73d2627b44f29931f32db4ca2e00">本质就是穷举法，通过对解空间进行深度优先遍历来寻找符合条件的解。在搜索过程中，遇到满足条件的解则记录，直至找到所有解或遍历完成后结束。</div><div class="notion-text notion-block-5e6feafa5b43475d958a5a790f929ab7">回溯算法的搜索过程包括尝试与回退两个部分。它通过深度优先搜索来尝试各种选择，当遇到不满足约束条件的情况时，则撤销上一步的选择，退回到之前的状态，并继续尝试其他选择。尝试与回退是两个方向相反的操作。</div><div class="notion-text notion-block-e4063ccafe0f4265aaafcde7930c70f1">回溯问题通常包含多个约束条件，它们可用于实现剪枝操作。剪枝可以提前结束不必要的搜索分支，大幅提升搜索效率。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-f5e217a5bf5148a2a0ef3b7e1240ba3e" data-id="f5e217a5bf5148a2a0ef3b7e1240ba3e"><span><div id="f5e217a5bf5148a2a0ef3b7e1240ba3e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f5e217a5bf5148a2a0ef3b7e1240ba3e" title="解题思路"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">解题思路</span></span></h4><div class="notion-blank notion-block-5b9a77a2a5024f358a31842b8fc802ff"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-c33eeba24c1149f093332184b0bb8274" data-id="c33eeba24c1149f093332184b0bb8274"><span><div id="c33eeba24c1149f093332184b0bb8274" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c33eeba24c1149f093332184b0bb8274" title="扩展"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">扩展</span></span></h2><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-c904b15ba8be417aafe5ca75c44ae514" href="https://www.hello-algo.com/"><div><div class="notion-bookmark-title">Hello 算法</div><div class="notion-bookmark-description">动画图解、一键运行的数据结构与算法教程</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://www.hello-algo.com/assets/images/favicon.png?t=c904b15b-a8be-417a-afe5-ca75c44ae514" alt="Hello 算法" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://www.hello-algo.com/</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-0df09fadf0db46ee8acf9e7d8b1e2880" href="https://mp.weixin.qq.com/s/DWGWK4yAlfEYO1Ynv1CMfg"><div><div class="notion-bookmark-title">95% 的算法都是基于这 6 种算法思想</div><div class="notion-bookmark-description">前端也能学到算法入门教程</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg?t=0df09fad-f0db-46ee-8acf-9e7d8b1e2880" alt="95% 的算法都是基于这 6 种算法思想" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://mp.weixin.qq.com/s/DWGWK4yAlfEYO1Ynv1CMfg</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="http://mmbiz.qpic.cn/mmbiz_jpg/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj8XojQG8uIHB4Bj8iaBHpicuB9wlzoLgr5OdicJcTIKdnL193yUR6dXvSg/0?wx_fmt=jpeg&amp;t=0df09fad-f0db-46ee-8acf-9e7d8b1e2880" alt="95% 的算法都是基于这 6 种算法思想" loading="lazy" decoding="async"/></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-aea49ac2c3524250b49595c5ec55f126" href="https://juejin.cn/post/6844903919722692621"><div><div class="notion-bookmark-title">前端该如何准备数据结构和算法？ - 掘金</div><div class="notion-bookmark-description">据我了解，前端程序员有相当一部分对“数据结构”和“算法”的基础概念都不是很清晰，这直接导致很多人在看到有关这部分的内容就会望而却步。 实际上，当你了解了“数据结构”和“算法”存在的真正意义，以及一些实际的应用场景，对它有了一个整体的认知之后，你可能会对它产生强烈的兴趣。当然，它…</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=aea49ac2-c352-4250-b495-95c5ec55f126" alt="前端该如何准备数据结构和算法？ - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/6844903919722692621</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-b09100294d6b4bc5947fb5f107b66fab" href="https://www.conardli.top/docs/datastructure/"><div><div class="notion-bookmark-title">数据结构专题 | awesome-coding-js</div><div class="notion-bookmark-description">二叉树</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-text">https://www.conardli.top/docs/datastructure/</div></div></div></a></div><div class="notion-blank notion-block-987b1b3eb30c4e31bd1f8c9218155933"> </div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-78ac28b2fcea46c280ca3954bab11389" href="https://juejin.cn/post/6947842412102287373?searchId=20231128125330B1E0CBADCF36FC4BBF4F"><div><div class="notion-bookmark-title">字节跳动最爱考的 64 道算法题（JS版） - 掘金</div><div class="notion-bookmark-description">现在大厂面试中，算法题几乎为必考项，且近几年频现 LeetCode 真题，此篇为拿到字节、腾讯、京东 Offer 的笔者本人在准备面试过程中亲自刷过以及遇到过高频算法题。文章内容会分模块整理，对于笔者在面试过程中遇到的真题，会给予着重 【🔥】标出。 同时，可以毫不客气的说，如…</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=78ac28b2-fcea-46c2-80ca-3954bab11389" alt="字节跳动最爱考的 64 道算法题（JS版） - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/6947842412102287373?searchId=20231128125330B1E0CBADCF36FC4BBF4F</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-685346efc95d4da3a660175d4b90299e" href="https://codetop.cc/home"><div><div class="notion-bookmark-title">CodeTop 面试题目总结</div><div class="notion-bookmark-description">CodeTop用于汇总互联网大厂高频面试题，帮助大家更有针对性地刷Leetcode</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://codetop.cc/logo.jpg?t=685346ef-c95d-4da3-a660-175d4b90299e" alt="CodeTop 面试题目总结" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://codetop.cc/home</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-1f18ea5d774b4aaeb6a9c51c5ce20556" href="https://github.com/lewiscrow/WorkHardAndFindJob/blob/master/复习/面试/手撕字节跳动面试时出现过的算法题.md"><div><div class="notion-bookmark-title">github.com</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-text">https://github.com/lewiscrow/WorkHardAndFindJob/blob/master/复习/面试/手撕字节跳动面试时出现过的算法题.md</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-86cc1cdd0ca74d2384fe30053496186e" href="https://www.nowcoder.com/discuss/353157412674805760"><div><div class="notion-bookmark-title">字节跳动面试爱考的高频算法题_牛客网</div><div class="notion-bookmark-description">前言 hello~大家好，一直被催更字节跳动的帖子，历经数天的时间，这篇帖子终于来啦~ 欢迎大家star⭐我的Github仓库呀~目前已4.6k star 正文 我这次汇总了牛客上7.28日~10.23日的389篇字节跳动面经，共涉及207道leetcode编程题，_牛客网_牛客在手,offer不愁</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://static.nowcoder.com/fe/file/images/nowpick/web/www-favicon.ico?t=86cc1cdd-0ca7-4d23-84fe-30053496186e" alt="字节跳动面试爱考的高频算法题_牛客网" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://www.nowcoder.com/discuss/353157412674805760</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="https://static.nowcoder.com/fe/common/share-logo.png?t=86cc1cdd-0ca7-4d23-84fe-30053496186e" alt="字节跳动面试爱考的高频算法题_牛客网" loading="lazy" decoding="async"/></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-12fca9ad1ec94f36aff90909fa529eb2" href="https://www.nowcoder.com/exam/oj/ta?page=1&amp;tpId=13&amp;type=13"><div><div class="notion-bookmark-title">剑指offer_在线编程_牛客网</div><div class="notion-bookmark-description">该专题为剑指offer专题，题目均来自《剑指offer》，里面每道题带有练习模式和考试模式，可还原考试模式进行模拟，也可通过练习模式进行练习。</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://static.nowcoder.com/fe/file/images/nowpick/web/www-favicon.ico?t=12fca9ad-1ec9-4f36-aff9-0909fa529eb2" alt="剑指offer_在线编程_牛客网" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://www.nowcoder.com/exam/oj/ta?page=1&amp;tpId=13&amp;type=13</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="https://static.nowcoder.com/fe/common/share-logo.png?t=12fca9ad-1ec9-4f36-aff9-0909fa529eb2" alt="剑指offer_在线编程_牛客网" loading="lazy" decoding="async"/></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-2a525cdd6add48f5b4615627cd12cdb2" href="https://www.nowcoder.com/exam/oj"><div><div class="notion-bookmark-title">牛客网在线编程_算法篇_面试必刷TOP101</div><div class="notion-bookmark-description">牛客网在线编程算法篇-面试必刷TOP101提供超多数据结构,系统设计,编程学习,练习题等,为技术求职者提供能力提升解决方案,同时为企业级用户提供更高效的招聘解决方案,帮助求职者与企业搭建人才招募和人才培养渠道</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://static.nowcoder.com/fe/file/images/nowpick/web/www-favicon.ico?t=2a525cdd-6add-48f5-b461-5627cd12cdb2" alt="牛客网在线编程_算法篇_面试必刷TOP101" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://www.nowcoder.com/exam/oj</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="https://static.nowcoder.com/fe/common/share-logo.png?t=2a525cdd-6add-48f5-b461-5627cd12cdb2" alt="牛客网在线编程_算法篇_面试必刷TOP101" loading="lazy" decoding="async"/></div></a></div></main></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于react 的状态管理]]></title>
        <id>https://tangly1024.com/article/b541bd58-28a7-4757-827f-b566f926df19</id>
        <link href="https://tangly1024.com/article/b541bd58-28a7-4757-827f-b566f926df19"/>
        <updated>2023-10-22T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<div id="notion-article" class="mx-auto overflow-hidden "><main class="notion light-mode notion-page notion-block-b541bd5828a74757827fb566f926df19"><div class="notion-viewport"></div><div class="notion-collection-page-properties"></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-0e15c515a4c14051abdb2708d2ca485c" data-id="0e15c515a4c14051abdb2708d2ca485c"><span><div id="0e15c515a4c14051abdb2708d2ca485c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0e15c515a4c14051abdb2708d2ca485c" title="Provider + Context（useContext）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Provider + Context（useContext）</span></span></h2><div class="notion-text notion-block-f7efbc9a5a064997b0601db575189125">一个完整的例子</div><hr class="notion-hr notion-block-b509340a20674643a93c569f37e52810"/><div class="notion-text notion-block-878674e74d6d4ad4b18a262b53c299d3">context 可以实现基础的状态共享。步骤：</div><ol start="1" class="notion-list notion-list-numbered notion-block-0cb5a9ee69b74f5e9f8a5d358b4f8793"><li>通过createContext创建一个Context，并设置默认值。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-6a02a91cf9a24ea8a1c6d142a0752977"><li>Context 中的值都在 Provider 的作用域下有效。所以在最外层包一个 Provider，value中设置传递值。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-ed27513f1500481c8062ffa77395192c"><li>如果子组件需要时，则通过 React.useContext拿到Context值。</li></ol><div class="notion-text notion-block-9d6e6ce6831040d0a34e9daec572d71e">缺点：</div><ol start="1" class="notion-list notion-list-numbered notion-block-f597572e83f54c018b03a8b9734bedb3"><li>重复渲染，性能差</li></ol><div class="notion-text notion-block-8b6ee7688f104acca04773d6fc1088f0">当 Context 中的某个属性发生变化时，所有使用该 Context 的子组件都会被重新渲染，即使某些组件可能并未使用到这个属性。</div><blockquote class="notion-quote notion-block-326ca5eaa5bb4c3081f47f416fb85784"><div>这种问题有两种解决方法：</div><ol start="1" class="notion-list notion-list-numbered notion-block-231afed0170c42388f72f66bb143c9cc"><li>React.memo 和 shouldComponentUpdate 这两种方式来解决。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-6be5e028b7f64d32921a40fb3555fcca"><li>将一个大型的 Context 拆分成多个小的 Context，可以精细地控制每个 Context 的更新，从而减少整个应用程序的重新渲染次数，提高性能和用户体验。</li></ol></blockquote><ol start="1" class="notion-list notion-list-numbered notion-block-6ff64a6d030442578762873090fc1cdf"><li>数据变更方法难以维护</li></ol><div class="notion-text notion-block-31739f1b13d94ae58120e69e59b4ddc8">为了保证数据变更方法的可维护性与 action 的不变性，有两种方法但各有问题：使用自定义 hooks，但为了不会重复渲染，每个修改方法需要使用useCallback，需要声明依赖，会造成极大的心智负担。使用useReducer，不支持异步函数、不支持内部的 reducer 互相调用，不支持和其他 state 联动（比如要当参数传进去才可用）。</div><ol start="1" class="notion-list notion-list-numbered notion-block-be3243312c98443ead07019d6f116cac"><li>使用范围限制</li></ol><div class="notion-text notion-block-28cb6a315687487eaaf373aa2b6183ac">context的store只能在react中使用，无法在外部函数使用，例如请求函数中需要store中的属性，不能直接在请求函数中调用，就只能通过react中作为参数传递。</div><ol start="1" class="notion-list notion-list-numbered notion-block-f188c3655cf1464799bb1e18a3076c09"><li>无法处理异步请求。</li></ol><div class="notion-text notion-block-4c5f8fb465c84a8fa5a617254d60befa">对于异步的逻辑，Context API并没有提供任何API，需要自己做封装。</div><ol start="1" class="notion-list notion-list-numbered notion-block-ca96ad888cae4b399dbdc3726c8e2853"><li>无法处理数据间的联动</li></ol><div class="notion-text notion-block-7def392215704eb59a9fdfbfb402b67f">Context API并没有提供API来生成派生状态，同样也需要自行去封装一些方法来实现。</div><div class="notion-blank notion-block-6e40a8f435b94c41ba5cdbe0d1a6063f"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-edad76fae1d249f09670b3d78fd2fcfa" data-id="edad76fae1d249f09670b3d78fd2fcfa"><span><div id="edad76fae1d249f09670b3d78fd2fcfa" class="notion-header-anchor"></div><a class="notion-hash-link" href="#edad76fae1d249f09670b3d78fd2fcfa" title="Redux"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>Redux</b></span></span></h2><div class="notion-text notion-block-323d07e408e14b94a2157c51ab04aad2">Redux 本身是一个 JavaScript 状态容器，提供可预测化状态的管理。社区通常认为 Redux 是 Flux 的一个简化设计版本，但它吸收了 Elm 的架构思想，更像一个混合产物。它提供的状态管理，简化了一些高级特性的实现成本，比如撤销、重做、实时编辑、时间旅行、服务端同构等。</div><div class="notion-text notion-block-a872cfcad66c459c97cabbf13c15f276">Redux 的核心设计包含了三大原则：</div><ol start="1" class="notion-list notion-list-numbered notion-block-6d7e2484c85943369415bc3433efb235"><li>单一数据源、</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-99b7569ab8b8401196c6aebb1f006ffa"><li>纯函数 Reducer、</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-f1c66e7cbc14472aae7c789fcd0a3aa3"><li>State 是只读的。</li></ol><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-33e4cb86a40842ccb30ddd987a71e54a" data-id="33e4cb86a40842ccb30ddd987a71e54a"><span><div id="33e4cb86a40842ccb30ddd987a71e54a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#33e4cb86a40842ccb30ddd987a71e54a" title="redux流程"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>redux流程</b></span></span></h3><ul class="notion-list notion-list-disc notion-block-3c41aea2befd4863ae636b0903384ecd"><li>用户（通过view）发出Action,发出方式是调用dispatch方法；</li></ul><ul class="notion-list notion-list-disc notion-block-c5c8d2d754d1492d9a21ed5348a4bc65"><li>Store自动调用 Reducer ,传入两个参数，当前state,收到的Action，Reducer 返回新的 State</li></ul><ul class="notion-list notion-list-disc notion-block-9d8c6b71bca045509dd92a784571a557"><li>state更新后，store就会调用监听函数， 根据state触发重新渲染，更新view</li></ul><div class="notion-text notion-block-c827f0773bd74221853676c69de6ad8e">整个流程中数据都是单向流动的，这种方式保证了流程的清晰</div><div class="notion-text notion-block-a4d7698ea07f4e92aa987428154a188a">核心概念：</div><ul class="notion-list notion-list-disc notion-block-b00eb0782c484640815def690b7bc922"><li><b>Store</b> :数据中心，整个应用只能有一个store</li></ul><ul class="notion-list notion-list-disc notion-block-8eced741b6ce4e91ac6aec4c5ff5e970"><li><b>State</b>: store对象包含的所有数据</li></ul><ul class="notion-list notion-list-disc notion-block-09304c10e18f40ea9c7783d85e11f858"><li><b>Action</b>: 用户触发的行为名称（通过action再去触发state的改变，最终响应view的改变）</li></ul><ul class="notion-list notion-list-disc notion-block-3bd7497150a34f509485def4d1127342"><li><b>Action Creator</b>: 生成action的函数，可生成多种action</li></ul><ul class="notion-list notion-list-disc notion-block-c9eb33056e6943f0a9d68aa884aec947"><li><b>Reducer</b>: store收到action后，处理state的函数，叫到reducer，接收两个参数：action ，和当前state；返回值： 新的state</li></ul><ul class="notion-list notion-list-disc notion-block-306379c579cb478f9bebce69a601fb9d"><li><b>Dispatch</b>: view发出action的唯一方法</li></ul><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-1609378890b144279c2e21225fc436db" data-id="1609378890b144279c2e21225fc436db"><span><div id="1609378890b144279c2e21225fc436db" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1609378890b144279c2e21225fc436db" title="Mobx"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>Mobx</b></span></span></h2><div class="notion-text notion-block-6ff7a87997a94882b6212233470f21f9">Mobx 通过监听数据的属性变化，可以直接在数据上更改触发UI 的渲染。在使用上更接近 Vue，比起 Flux 与 Redux 的手动挡的体验，更像开自动挡的汽车。Mobx 的响应式实现原理与 Vue 相同，以 Mobx 5 为分界点，5 以前采用 Object.defineProperty 的方案，5 及以后使用 Proxy 的方案。它的优点是样板代码少、简单粗暴、用户学习快、响应式自动更新数据让开发者的心智负担更低。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-c5c8fe776d164f90bdd0d36fbe4f43b6" data-id="c5c8fe776d164f90bdd0d36fbe4f43b6"><span><div id="c5c8fe776d164f90bdd0d36fbe4f43b6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c5c8fe776d164f90bdd0d36fbe4f43b6" title="Redux与 MobX的区别？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>Redux与 MobX的区别？</b></span></span></h3><div class="notion-text notion-block-2b7ea861b4104b099bda0be4ea77e486">【代码量】redux&gt;mobx</div><ul class="notion-list notion-list-disc notion-block-f3adedf7103c4e5cabfff168884a05f7"><li>redux： 需要定义一堆的action, dispatch,reducer</li></ul><ul class="notion-list notion-list-disc notion-block-74111da1d2bf454797dfbb562e055e0d"><li>mobx： store和改变的方法</li></ul><div class="notion-text notion-block-ce2774ad51924961b4f9411305062b1e">【开发难度】redux&gt;mobx</div><ul class="notion-list notion-list-disc notion-block-60a464774dcf4a8c857654aa9dc0655e"><li>mobx：使用面向对象的编程思维，相对简单</li></ul><ul class="notion-list notion-list-disc notion-block-2c3aab77c2294807b34dea3834767125"><li>redux：比较复杂，函数式编程思维，同时需要借助一系列的中间件来处理异步和副使用。</li></ul><div class="notion-text notion-block-8f4c4eef169d430a8c5fde3427d54c3e">【调试难度】mobx&gt;redux</div><ul class="notion-list notion-list-disc notion-block-67142a09e1994ad1be0250c3eb056354"><li>redux：状态不可变，返回一个新的状态，同时使用纯函数；redux 提供时间回溯的开发工具，同时纯函数以及更少的抽象，让调试变得更加容易</li></ul><ul class="notion-list notion-list-disc notion-block-c67432e0548641a19ee7efefce7a058d"><li>mobx：中状态可变，可对其直接修改，mobx中有更多的抽象和封装，调试比较困难，同时结果难预测。</li></ul><div class="notion-text notion-block-44adee4d14364945b4d26ae60bb206fe">【store数】</div><ul class="notion-list notion-list-disc notion-block-9c2d8818df094aba86b53b446e24f025"><li>redux：单个store。</li></ul><ul class="notion-list notion-list-disc notion-block-9d1b97ad01174fefbd9b27e4d3655de8"><li>mobx：多个store。</li></ul><div class="notion-text notion-block-55e3d78ba2a4403fa642e9802c30cb1c">【功能性】redux&gt; mobx</div><ul class="notion-list notion-list-disc notion-block-3a782ad1814f4291824ef02f18340c39"><li>redux: 可回溯状态，时间旅行，适合：画板应用，表格应用，很多时候需要撤销，重做等操作。</li></ul><ul class="notion-list notion-list-disc notion-block-e67c8570302e41ba903ff84349456959"><li>mobx: 直接修改源数据。</li></ul><div class="notion-text notion-block-050108d66cd040989af09ec1575d52da">适用场景总结：</div><ul class="notion-list notion-list-disc notion-block-f78f26f47eee4b38a484cbcdcf8fff8a"><li>mobx： 简单项目，适合数据不复杂的应用</li></ul><ul class="notion-list notion-list-disc notion-block-8d949b7bb18747f5b63add19a53e2abc"><li>redux：大型项目，有回溯需求</li></ul><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-1859196257af4cae9c254735a7ffe789" data-id="1859196257af4cae9c254735a7ffe789"><span><div id="1859196257af4cae9c254735a7ffe789" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1859196257af4cae9c254735a7ffe789" title="valtio"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">valtio</span></span></h2><div class="notion-text notion-block-202c6717de774d35b28f174c0d40addc">类似于mobx。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f752d5b98adf4f39afcf3d9712e08370" data-id="f752d5b98adf4f39afcf3d9712e08370"><span><div id="f752d5b98adf4f39afcf3d9712e08370" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f752d5b98adf4f39afcf3d9712e08370" title="原理"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">原理</span></span></h3><div class="notion-text notion-block-5c4be2f412dc456ca0263a4a9a8e98e3">altio 的实现主要依赖两个核心方法：proxy 和 useSnapshot。</div><div class="notion-text notion-block-1587b14a80cc44489caef383b40399cf">proxy 用于包装原始对象（initialObject)，生成一个可监听修改操作的 proxy state。</div><div class="notion-text notion-block-f898ddcce77d4a89ba27399a2d8623bc">在组件中，使用 useSnapshot来获取这个proxy state，并返回一个不可变的snapshot。这个snapshot用于组件渲染，当状态需要变更时，我们可以操作proxy state 获取新的 snapshot，触发组件 rerender。</div><div class="notion-text notion-block-3231d536e42a457cb3c9b35ed6432b50">这其实就是一种<b>发布－订阅模式</b>的实现：创建代理对象并监听操作，通过内部机制通知所有依赖这些状态的组件进行更新。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d55eb70e32b642d38b58ded43b124f84"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fde5ea524-b729-4eea-845e-59eaf20e7149%2F565a81fd-bb43-4d46-a862-51363f672313%2FUntitled.png?table=block&amp;id=d55eb70e-32b6-42d3-8b58-ded43b124f84&amp;t=d55eb70e-32b6-42d3-8b58-ded43b124f84&amp;width=1946&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-1dc7aac1527347799414aca454d75ced" data-id="1dc7aac1527347799414aca454d75ced"><span><div id="1dc7aac1527347799414aca454d75ced" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1dc7aac1527347799414aca454d75ced" title="Zustand"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Zustand</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e9641f087e87403481a6e5a2c0056a1d" data-id="e9641f087e87403481a6e5a2c0056a1d"><span><div id="e9641f087e87403481a6e5a2c0056a1d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e9641f087e87403481a6e5a2c0056a1d" title="状态共享"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">状态共享</span></span></h3><div class="notion-text notion-block-c9c8f0ea187447b2bdab497b3bc08022">context需要在最外层包一个 Provider。 Context 中的值都在 Provider 的作用域下有效。而 zustand默认是单例模式， <b>不需要 Provider</b>。直接声明一个 hooks 式的 useStore 后就可以在不同组件中进行调用。</div><blockquote class="notion-quote notion-block-ad25dd16db28453f93ca12ee8cd41e10"><div>如果需要多实例的话，zustand 也提供了对应的 Provider 的书写方式，</div></blockquote><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-c4da8c83251d48eeb93c89a23b4be3cd" data-id="c4da8c83251d48eeb93c89a23b4be3cd"><span><div id="c4da8c83251d48eeb93c89a23b4be3cd" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c4da8c83251d48eeb93c89a23b4be3cd" title="状态变更"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">状态变更</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-7aef97778d5c453e9a1cef54dc2c8fcd"><li>函数可以直接写，完全不用区分同步或者异步。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-d08ad45c0b404117b6611827cbbb2272"><li><b>zustand 会默认将所有的函数保持同一引用</b>。用 zustand 写的方法，默认都不会造成额外的重复渲染。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-c0fa1ff7ff704ed085554f09251e3aa7"><li>更好的状态内聚性，可以互相调用，不用再重新声明函数。</li></ol><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-5d44403ed3a74014a2867829b4dcc7e9" data-id="5d44403ed3a74014a2867829b4dcc7e9"><span><div id="5d44403ed3a74014a2867829b4dcc7e9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5d44403ed3a74014a2867829b4dcc7e9" title="状态派生"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">状态派生</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-4b3ed15ed6da44729b99aa687706aa58"><li>zustand 用了类似 redux selector 的方法，实现相应的状态派生。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-d6e7e53acb07447ca9f67000003a279a"><li>可以实现只有监听的属性变化，才会重新渲染</li></ol><hr class="notion-hr notion-block-c7aa12360e9b40679d99b1b491365173"/><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-afa76d4b956e4893baf43f0f8bbe3844" data-id="afa76d4b956e4893baf43f0f8bbe3844"><span><div id="afa76d4b956e4893baf43f0f8bbe3844" class="notion-header-anchor"></div><a class="notion-hash-link" href="#afa76d4b956e4893baf43f0f8bbe3844" title="状态组合"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">状态组合</span></span></h3><div class="notion-text notion-block-0af2cc5daf814ad1b818b7861c3c4a00">可以将相关的状态进行组合，结合中间件实现对单个状态组合进行一些操作，例如对状态组合实现持久化，缓存到localStorage</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-ef78874113de4172bf8df9ce2345146e" data-id="ef78874113de4172bf8df9ce2345146e"><span><div id="ef78874113de4172bf8df9ce2345146e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ef78874113de4172bf8df9ce2345146e" title="多环境集成"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">多环境集成</span></span></h3><div class="notion-text notion-block-429e41e03deb4b8a9c8d0d5d61d97361">可以不在 react 环境内直接获取状态数据</div><hr class="notion-hr notion-block-46d351f33a494c9f91ed86cda5f915d4"/><blockquote class="notion-quote notion-block-1415476d08ac4bcb90ace580a36bc4a5"><div>引用：</div><div class="notion-text notion-block-79aacc13dc364d4f88f944404c230bbb"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://juejin.cn/post/7177216308843380797">谈谈复杂应用的状态管理（上）：为什么是 Zustand</a></div><div class="notion-text notion-block-feb5b53c43ec4e3fb7ccd90d0a1878ba"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/pmndrs/zustand">https://github.com/pmndrs/zustand</a></div></blockquote><div class="notion-blank notion-block-d117200f28d94753ae05529dff849274"> </div><div class="notion-blank notion-block-6b5dbca3ea274de3a05141dfdd1be2d0"> </div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-572858887f914c928743333d7126fa44" href="https://xz-fe-interview.gitbook.io/fe-interview/redux"><div><div class="notion-bookmark-title">redux</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://app.gitbook.com/public/emojis/1f4d6.png?v=6.0.0&amp;t=57285888-7f91-4c92-8743-333d7126fa44" alt="redux" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://xz-fe-interview.gitbook.io/fe-interview/redux</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="https://app.gitbook.com/share/space/thumbnail/-MKgXfDzKhEvAA-wOrky/page/-MUr2gQN2lC2AsT3ZVyr.png?color=%233884FF&amp;logo=&amp;theme=default&amp;t=57285888-7f91-4c92-8743-333d7126fa44" alt="redux" loading="lazy" decoding="async"/></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-7a0146db8bc143f38fa682289fa5245d" href="https://mp.weixin.qq.com/s/h8uRkY8wzzP-ajmEIHkzwQ"><div><div class="notion-bookmark-title">【第2426期】各流派React状态管理对比和原理实现</div><div class="notion-bookmark-description">硬核长文</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg?t=7a0146db-8bc1-43f3-8fa6-82289fa5245d" alt="【第2426期】各流派React状态管理对比和原理实现" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://mp.weixin.qq.com/s/h8uRkY8wzzP-ajmEIHkzwQ</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="http://mmbiz.qpic.cn/mmbiz_jpg/meG6Vo0Mevj2AU9pvKqn1ogfP6SiaktAiaWuLYGz5Ca83fWMtPowleQQSEBm0RPQQdmqctBpkpIKgHc6GzLibAdng/0?wx_fmt=jpeg&amp;t=7a0146db-8bc1-43f3-8fa6-82289fa5245d" alt="【第2426期】各流派React状态管理对比和原理实现" loading="lazy" decoding="async"/></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-8f43f0616a4e45558e4b086be5ccbb3d" href="https://lxw15337674.github.io/posts/react/store/"><div><div class="notion-bookmark-title">Flux、Redux、Vuex、MobX 状态管理</div><div class="notion-bookmark-description">状态管理的解决思路是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。 store模式 简单模式 把状态存到一</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lxw15337674.github.io/apple-touch-icon.png?t=8f43f061-6a4e-4555-8e4b-086be5ccbb3d" alt="Flux、Redux、Vuex、MobX 状态管理" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://lxw15337674.github.io/posts/react/store/</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-81ef4966674c48cba03fdaec8b77e23a" href="https://mp.weixin.qq.com/s/ayfhPg73g73uvB1WZpn39A"><div><div class="notion-bookmark-title">【第3139期】Reac状态管理比较与原理实现. Redux,Zustand,Jotai,Recoil, MobX,Valtio</div><div class="notion-bookmark-description">探讨不同的 React 状态管理组件解决问题的不同方法和原理</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg?t=81ef4966-674c-48cb-a03f-daec8b77e23a" alt="【第3139期】Reac状态管理比较与原理实现. Redux,Zustand,Jotai,Recoil, MobX,Valtio" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://mp.weixin.qq.com/s/ayfhPg73g73uvB1WZpn39A</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/meG6Vo0MeviaxwawL04EOnnvzo7gM6DYpgAVZMPlvcjiaBNibP6y7BRibztpMWoD6JqqLQFNnKQvNiafa5tngtwTjYg/0?wx_fmt=jpeg&amp;t=81ef4966-674c-48cb-a03f-daec8b77e23a" alt="【第3139期】Reac状态管理比较与原理实现. Redux,Zustand,Jotai,Recoil, MobX,Valtio" loading="lazy" decoding="async"/></div></a></div></main></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟滚动]]></title>
        <id>https://tangly1024.com/article/680a853c-5852-486b-927e-2be080d55b26</id>
        <link href="https://tangly1024.com/article/680a853c-5852-486b-927e-2be080d55b26"/>
        <updated>2024-01-07T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<div id="notion-article" class="mx-auto overflow-hidden "><main class="notion light-mode notion-page notion-block-680a853c5852486b927e2be080d55b26"><div class="notion-viewport"></div><div class="notion-collection-page-properties"></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-115cdb6fe040425cbb2740ec8c722bba" data-id="115cdb6fe040425cbb2740ec8c722bba"><span><div id="115cdb6fe040425cbb2740ec8c722bba" class="notion-header-anchor"></div><a class="notion-hash-link" href="#115cdb6fe040425cbb2740ec8c722bba" title="痛点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">痛点</span></span></h2><div class="notion-text notion-block-1c544b47a3384360b85bf0e7db3470b3">当表格数据太多时，会渲染出太多的DOM元素(例如100行100列的数据，会渲染出10000个td元素)，出现严重的卡顿。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-7e21c2f08fcb4891a34d81631ac63ea1" data-id="7e21c2f08fcb4891a34d81631ac63ea1"><span><div id="7e21c2f08fcb4891a34d81631ac63ea1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#7e21c2f08fcb4891a34d81631ac63ea1" title="思考过程"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">思考过程</span></span></h2><div class="notion-text notion-block-f443ed7d51804d6896c449bca98fbf80">想到两种方案：懒加载和虚拟滚动。</div><ul class="notion-list notion-list-disc notion-block-359f12821b5d4edaaacfc3876c4852cf"><li>懒加载：即首次只渲染当前显示节点，当滚动时再插入后面的节点，懒加载的问题在于只能解决首次渲染的问题，后面仍会渲染所有的dom节点。</li></ul><ul class="notion-list notion-list-disc notion-block-5b363769b10442ba8b81da831e1d434a"><li>虚拟滚动：即只显示当前可视区域的节点，当滚动时改变动态更新可视区域的节点。好处在于可以复用已渲染的dom节点。</li></ul><div class="notion-text notion-block-5fe4865a84824380ad13b90d63a2bb80">所以最好的方案是采取虚拟滚动</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-84387cfdb5f24a7d9e2988e383e0a91d" data-id="84387cfdb5f24a7d9e2988e383e0a91d"><span><div id="84387cfdb5f24a7d9e2988e383e0a91d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#84387cfdb5f24a7d9e2988e383e0a91d" title="基本思路"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">基本思路</span></span></h2><div class="notion-text notion-block-87bd009ea18e4c34b475f14eeab53c32">通过「<b>单个元素高度</b>」计算当前列表全部加载时的高度作为「<b>滚动容器</b>」的「<b>可滚动高度</b>」，按该「<b>可滚动高度</b>」撑开「<b>滚动容器</b>」。监听滚动容器的滚动事件，根据「<b>当前滚动高度</b>」，在「<b>可视区域</b>」内按需加载列表元素。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e4d0b4edbf3c4bda914143e27e8038a4" data-id="e4d0b4edbf3c4bda914143e27e8038a4"><span><div id="e4d0b4edbf3c4bda914143e27e8038a4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e4d0b4edbf3c4bda914143e27e8038a4" title="固定高度的虚拟列表"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">固定高度的虚拟列表</span></span></h3><div class="notion-text notion-block-3d09818e57da4da1a565307aadd3b5ae">根据滚动位置计算出可视元素。再额外渲染上下两个锚点元素，利用intersectionObserver判断，如果锚点元素进入可视范围则再次计算可视元素。</div><div class="notion-blank notion-block-3aceb0be609a4ac285480eb260eda588"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f6c4e8907ab9433c9260f50334f9a481" data-id="f6c4e8907ab9433c9260f50334f9a481"><span><div id="f6c4e8907ab9433c9260f50334f9a481" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f6c4e8907ab9433c9260f50334f9a481" title="动态高度的虚拟列表"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">动态高度的虚拟列表</span></span></h3><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-a6590ea4e3174df1b32dd1b722a20377" data-id="a6590ea4e3174df1b32dd1b722a20377"><span><div id="a6590ea4e3174df1b32dd1b722a20377" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a6590ea4e3174df1b32dd1b722a20377" title="场景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">场景</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-39e8802f3a6745b88c4d1cf9d72956dc"><li>列表元素内初始渲染时高度就不确定。比如<b>不定行数</b>的多行文本、列表元素内包含<b>不定长度</b>的内嵌列表等；</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-dd3add93a8494bb493ed926e7955c8fe"><li>列表元素内初始渲染后因用户操作而高度发生变化。比如展开一个<b>收缩项目</b>、<b>删除或增加</b>子元素等；</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-d97e26f444e1404893744fabd264e5aa"><li>列表元素内包含异步渲染元素。比如未缓存过的<b>图片</b>、<b>异步组件</b>等。</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-075a7c3c930d4598ae5b3a9197ab1833" data-id="075a7c3c930d4598ae5b3a9197ab1833"><span><div id="075a7c3c930d4598ae5b3a9197ab1833" class="notion-header-anchor"></div><a class="notion-hash-link" href="#075a7c3c930d4598ae5b3a9197ab1833" title="解决方法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">解决方法</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-8a485a83211e4216a087a97702bef1bf"><li>利用<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver">ResizeObserver</a>，实时监听每一个<b>处于可视区域</b>内的元素的高度变化，更新元素高度表。存储元素实际高度，如果元素未渲染或者被略过渲染时，用<b>估算高度</b>进行暂时代替。</li></ol><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-5916a69bb2704b70b48ad297d9018ca5" data-id="5916a69bb2704b70b48ad297d9018ca5"><span><div id="5916a69bb2704b70b48ad297d9018ca5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5916a69bb2704b70b48ad297d9018ca5" title="问题"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">问题</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-1d1dfdcc9f964dbab44241c7ce6e74c6"><li>动态高度
多行文本、图片之类的可变内容，会导致列表项的高度并不相同。
解决方法： 以预估高度先行渲染，然后获取真实高度并缓存。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-4b968a532b5747c88fdaae1d20145e03"><li>白屏闪烁
回调执行也有执行耗时，如果滑动过快会出现白屏/闪烁的情况。为了使页面平滑滚动，我们还需要在可见区域的上方和下方渲染额外的项目，给滚动回调一些缓冲时间。</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-a0254d2f96e34346bc1cd4c2a329b25a" data-id="a0254d2f96e34346bc1cd4c2a329b25a"><span><div id="a0254d2f96e34346bc1cd4c2a329b25a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a0254d2f96e34346bc1cd4c2a329b25a" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-db1d36e6a55646bebf41b7bcfaef8cfe"><li><b>当前元素的上一个元素高度发生了变化。</b> 这种情况意味着从<b>当前元素</b>开始，每一个后续元素都需要按<b>上一个元素</b>的高度差值进行「scrollY」计算。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-c6c3b551cb274a1ab9b34f96bcfa6eca"><li><b>用户快速拖动滚动条时。</b> 由于略过了中间元素的渲染，<code class="notion-inline-code">cachedHeight</code>会缺少略过元素的真实高度，所以只能用上文的<code class="notion-inline-code">ESTIMATED_HEIGHT</code>进行代替。这种情况下用户再缓慢滚动到顶部时，略过元素的初次渲染会更新<code class="notion-inline-code">cachedHeight</code>中对应的记录。此时更新的高度肯定是大于或者小于<code class="notion-inline-code">ESTIMATED_HEIGHT</code>的，所以当用户持续滚动缓慢滚动到<code class="notion-inline-code">scrollTop</code>为 0 时，可能会出现 <em><b>上部滚动区域</b></em>「不足」或者「多余」的情况。因此，必须在<b>保证当前页面滚动情况不变</b>的前提下，提前对这两种情况进行实时修正，也即修正<code class="notion-inline-code">scrollTop</code>的同时重新计算「锚点元素」。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-058bdda87360437ca724203040e593cf"><li>屏幕尺寸变化。当屏幕尺寸变化，可能导致滚动容器的宽高发生变化。可能会影响元素的宽高和可视元素的个数。所以需要重新计算。</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-541a6adb8156420bb19faa486764feb7" data-id="541a6adb8156420bb19faa486764feb7"><span><div id="541a6adb8156420bb19faa486764feb7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#541a6adb8156420bb19faa486764feb7" title="问题"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">问题</span></span></h4><div class="notion-text notion-block-98a4c033aede48eb9c308fe9bed89022">无法定位跳转到未渲染元素，因为不知道元素的实际高度</div><div class="notion-blank notion-block-24e275adbb2546baa8df81df21672d12"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-5e04b887f2f84af3aec328b9f5e02c49" data-id="5e04b887f2f84af3aec328b9f5e02c49"><span><div id="5e04b887f2f84af3aec328b9f5e02c49" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5e04b887f2f84af3aec328b9f5e02c49" title="实现过程"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">实现过程</span></span></h2><ol start="1" class="notion-list notion-list-numbered notion-block-2343708972a44009b9b09d172d3db8ec"><li>根据饿了么的<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zhuanlan.zhihu.com/p/34585166">再谈前端虚拟列表的实现</a>，实现了虚拟滚动的vue组件，但是存在问题：如果元素的长度不同时，在滚动的过程中仍会增删元素，会影响性能。在我实现虚拟滚动的表格时，因为要实现横纵双向虚拟滚动，dom元素的成倍增加，导致页面会出现明显的卡顿。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-576d2561373245948bd3c8dcd7574207"><li>根据谷歌的<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://juejin.im/post/58a3c81e128fe10058c57a8b#heading-1">无尽滚动的复杂度 -- 来自 Google 大神的拆解</a>，通过DOM回收的机制，最大程度利用已经创建的DOM元素，尽最大可能减少dom的消耗。</li></ol><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-cd6df9542f1044d5a739e6b9da95450e" data-id="cd6df9542f1044d5a739e6b9da95450e"><span><div id="cd6df9542f1044d5a739e6b9da95450e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#cd6df9542f1044d5a739e6b9da95450e" title="参考"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考</span></span></h2><div class="notion-text notion-block-ad14d4680b6b42b9bce77c69e0d0360c"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zhuanlan.zhihu.com/p/34585166">再谈前端虚拟列表的实现</a></div><div class="notion-text notion-block-8036edc0146f46ae9c0d01cfe08e4fe7"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://juejin.im/post/58a3c81e128fe10058c57a8b#heading-1">无尽滚动的复杂度 -- 来自 Google 大神的拆解</a></div><div class="notion-blank notion-block-d85ddd0dea2a4504b289e8ba9e4b6314"> </div><a target="_blank" rel="noopener noreferrer" href="https://github.com/lkangd/infinite-scroll-sample" class="notion-external notion-external-block notion-row notion-block-9eedcac901554bb8a10daac613af94b5"><div class="notion-external-image"><svg viewBox="0 0 260 260"><g><path d="M128.00106,0 C57.3172926,0 0,57.3066942 0,128.00106 C0,184.555281 36.6761997,232.535542 87.534937,249.460899 C93.9320223,250.645779 96.280588,246.684165 96.280588,243.303333 C96.280588,240.251045 96.1618878,230.167899 96.106777,219.472176 C60.4967585,227.215235 52.9826207,204.369712 52.9826207,204.369712 C47.1599584,189.574598 38.770408,185.640538 38.770408,185.640538 C27.1568785,177.696113 39.6458206,177.859325 39.6458206,177.859325 C52.4993419,178.762293 59.267365,191.04987 59.267365,191.04987 C70.6837675,210.618423 89.2115753,204.961093 96.5158685,201.690482 C97.6647155,193.417512 100.981959,187.77078 104.642583,184.574357 C76.211799,181.33766 46.324819,170.362144 46.324819,121.315702 C46.324819,107.340889 51.3250588,95.9223682 59.5132437,86.9583937 C58.1842268,83.7344152 53.8029229,70.715562 60.7532354,53.0843636 C60.7532354,53.0843636 71.5019501,49.6441813 95.9626412,66.2049595 C106.172967,63.368876 117.123047,61.9465949 128.00106,61.8978432 C138.879073,61.9465949 149.837632,63.368876 160.067033,66.2049595 C184.49805,49.6441813 195.231926,53.0843636 195.231926,53.0843636 C202.199197,70.715562 197.815773,83.7344152 196.486756,86.9583937 C204.694018,95.9223682 209.660343,107.340889 209.660343,121.315702 C209.660343,170.478725 179.716133,181.303747 151.213281,184.472614 C155.80443,188.444828 159.895342,196.234518 159.895342,208.176593 C159.895342,225.303317 159.746968,239.087361 159.746968,243.303333 C159.746968,246.709601 162.05102,250.70089 168.53925,249.443941 C219.370432,232.499507 256,184.536204 256,128.00106 C256,57.3066942 198.691187,0 128.00106,0 Z M47.9405593,182.340212 C47.6586465,182.976105 46.6581745,183.166873 45.7467277,182.730227 C44.8183235,182.312656 44.2968914,181.445722 44.5978808,180.80771 C44.8734344,180.152739 45.876026,179.97045 46.8023103,180.409216 C47.7328342,180.826786 48.2627451,181.702199 47.9405593,182.340212 Z M54.2367892,187.958254 C53.6263318,188.524199 52.4329723,188.261363 51.6232682,187.366874 C50.7860088,186.474504 50.6291553,185.281144 51.2480912,184.70672 C51.8776254,184.140775 53.0349512,184.405731 53.8743302,185.298101 C54.7115892,186.201069 54.8748019,187.38595 54.2367892,187.958254 Z M58.5562413,195.146347 C57.7719732,195.691096 56.4895886,195.180261 55.6968417,194.042013 C54.9125733,192.903764 54.9125733,191.538713 55.713799,190.991845 C56.5086651,190.444977 57.7719732,190.936735 58.5753181,192.066505 C59.3574669,193.22383 59.3574669,194.58888 58.5562413,195.146347 Z M65.8613592,203.471174 C65.1597571,204.244846 63.6654083,204.03712 62.5716717,202.981538 C61.4524999,201.94927 61.1409122,200.484596 61.8446341,199.710926 C62.5547146,198.935137 64.0575422,199.15346 65.1597571,200.200564 C66.2704506,201.230712 66.6095936,202.705984 65.8613592,203.471174 Z M75.3025151,206.281542 C74.9930474,207.284134 73.553809,207.739857 72.1039724,207.313809 C70.6562556,206.875043 69.7087748,205.700761 70.0012857,204.687571 C70.302275,203.678621 71.7478721,203.20382 73.2083069,203.659543 C74.6539041,204.09619 75.6035048,205.261994 75.3025151,206.281542 Z M86.046947,207.473627 C86.0829806,208.529209 84.8535871,209.404622 83.3316829,209.4237 C81.8013,209.457614 80.563428,208.603398 80.5464708,207.564772 C80.5464708,206.498591 81.7483088,205.631657 83.2786917,205.606221 C84.8005962,205.576546 86.046947,206.424403 86.046947,207.473627 Z M96.6021471,207.069023 C96.7844366,208.099171 95.7267341,209.156872 94.215428,209.438785 C92.7295577,209.710099 91.3539086,209.074206 91.1652603,208.052538 C90.9808515,206.996955 92.0576306,205.939253 93.5413813,205.66582 C95.054807,205.402984 96.4092596,206.021919 96.6021471,207.069023 Z" fill="#161614"></path></g></svg></div><div class="notion-external-description"><div class="notion-external-title">infinite-scroll-sample</div><div class="notion-external-subtitle"><span>lkangd</span><span> • </span><span>Updated <!-- -->Dec 15, 2023</span></div></div></a><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-eaf88171edba4af08630119a8b24e254" href="https://cloud.tencent.com/developer/article/2327911"><div><div class="notion-bookmark-title">虚拟滚动的 3 种实现方式！-腾讯云开发者社区-腾讯云</div><div class="notion-bookmark-description">工作中一直有接触大量数据渲染的业务，使用react-window多之又多，所以对虚拟列表有了些浅显的理解。今天，我们就照着react-window的使用方式来实现三种虚拟列表。</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://cloud.tencent.com/favicon.ico?t=eaf88171-edba-4af0-8630-119a8b24e254" alt="虚拟滚动的 3 种实现方式！-腾讯云开发者社区-腾讯云" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://cloud.tencent.com/developer/article/2327911</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="https://cloudcache.tencentcs.com/open_proj/proj_qcloud_v2/gateway/shareicons/cloud.png?t=eaf88171-edba-4af0-8630-119a8b24e254" alt="虚拟滚动的 3 种实现方式！-腾讯云开发者社区-腾讯云" loading="lazy" decoding="async"/></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-1016c2b03bd449abad1484a4bd58def5" href="https://www.cnblogs.com/coco1s/p/16373817.html"><div><div class="notion-bookmark-title">使用 content-visibility 优化渲染性能 - ChokCoco - 博客园</div><div class="notion-bookmark-description">最近在业务中实际使用 content-visibility 进了一些渲染性能的优化。 这是一个比较新且有强大功能的属性。本文将带领大家深入理解一番。 何为 content-visibility？ content-visibility：属性控制一个元素是否渲染其内容，它允许用户代理（浏览器）潜在地省略</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://common.cnblogs.com/favicon.svg?t=1016c2b0-3bd4-49ab-ad14-84a4bd58def5" alt="使用 content-visibility 优化渲染性能 - ChokCoco - 博客园" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://www.cnblogs.com/coco1s/p/16373817.html</div></div></div></a></div></main></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[首屏渲染方式]]></title>
        <id>https://tangly1024.com/article/render</id>
        <link href="https://tangly1024.com/article/render"/>
        <updated>2023-07-01T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[首屏渲染]]></summary>
        <content type="html"><![CDATA[<div id="notion-article" class="mx-auto overflow-hidden "><main class="notion light-mode notion-page notion-block-fd29a7f9c8104e118bddea624b26f347"><div class="notion-viewport"></div><div class="notion-collection-page-properties"></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-ce509f5379fa4a62a712e60d6fa5a37b" data-id="ce509f5379fa4a62a712e60d6fa5a37b"><span><div id="ce509f5379fa4a62a712e60d6fa5a37b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ce509f5379fa4a62a712e60d6fa5a37b" title="静态页面生成 SSG (Static Site Generation)"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">静态页面生成 SSG (Static Site Generation)</span></span></h3><div class="notion-text notion-block-365ccbdef8e64ee69f92154d6bad0819">在项目构建时生成包含内容的html，之后将相应的html、js、css等静态资源发布到相应的CDN节点，这样当用户进行访问时页面可直接渲染便较好的性能，尤其适合公司官网等变动频率不高的静态资源。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-78a1032a86c44299a30d5e90c9b2df38" data-id="78a1032a86c44299a30d5e90c9b2df38"><span><div id="78a1032a86c44299a30d5e90c9b2df38" class="notion-header-anchor"></div><a class="notion-hash-link" href="#78a1032a86c44299a30d5e90c9b2df38" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-4e586e5e1f4244e8bb4af2b935ebb054"><li>静态页面生成的性能较好，适用于变动频率不高的静态资源。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-cdc83771aa4a49b1aa34bb9689805a0f"><li>服务端渲染可以根据数据生成最新的HTML，首屏渲染速度较快，SEO效果好。</li></ol><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-b295f46c397740f8a8100e2911037e21" data-id="b295f46c397740f8a8100e2911037e21"><span><div id="b295f46c397740f8a8100e2911037e21" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b295f46c397740f8a8100e2911037e21" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-26825186ad4f4f4585ef194d56c2ecaa"><li>所有用户看到的都是同一个页面，无法生成用户相关内容。</li></ol><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-8962f690a9284c59b446b6078905c653" data-id="8962f690a9284c59b446b6078905c653"><span><div id="8962f690a9284c59b446b6078905c653" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8962f690a9284c59b446b6078905c653" title="客户端渲染 CSR(Client Side Render)"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">客户端渲染 CSR(<b><b>Client </b></b>Side Render)</span></span></h2><div class="notion-blank notion-block-0f752599e6e145139c34a95a0060f2b4"> </div><div class="notion-text notion-block-af5dc42417fb4e87a8fd427bc1f7a394">指在 Web 应用程序中，页面的生成和呈现是在浏览器端（即客户端）完成的一种渲染方式。在浏览器中生成HTML，每次用户请求时只返回一个简单的HTML模板，然后在浏览器中使用JavaScript加载数据，生成和渲染页面。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-87083b995340418693775bcf1d26d2c4" data-id="87083b995340418693775bcf1d26d2c4"><span><div id="87083b995340418693775bcf1d26d2c4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#87083b995340418693775bcf1d26d2c4" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-b7ceb947ff49471dba6570dbdaaf5c20"><li>白屏：客户端渲染需要浏览器先下载HTML和JavaScript资源文件，然后再解析和渲染页面，过程比较耗时，可能会导致白屏时间较长。</li></ol><details class="notion-toggle notion-block-ac4c21587ca746a4ab16abaee42ca44d"><summary>白屏时间</summary><div><div class="notion-text notion-block-62268b5d093d4429a6d78c8d98b906af">是指用户在加载网站或应用时，从页面请求发起到页面架构完毕并且首屏内容显示出来之间的时间。在这段时间内，用户可能直面一片空白，无法察觉到页面正在加载。</div></div></details><ol start="1" class="notion-list notion-list-numbered notion-block-09eb84a3cf3d4641bfb827b2717b05f5"><li>SEO效果差：客户端渲染的页面内容一般是通过JavaScript动态生成的，而搜索引擎爬虫很难获取到这些内容，从而影响网站的SEO排名。</li></ol><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-9cff3f128e3b41b19b634a44ea630613" data-id="9cff3f128e3b41b19b634a44ea630613"><span><div id="9cff3f128e3b41b19b634a44ea630613" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9cff3f128e3b41b19b634a44ea630613" title="服务端渲染 SSR（Server Side Rendering）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">服务端渲染 SSR（Server Side Rendering）</span></span></h2><div class="notion-text notion-block-f5731bc865904a1ea22561e5f3f79624">每次用户请求时动态生成HTML，将生成好的HTML返回给用户。这种方式可以在每次请求时根据数据生成最新的HTML，但是相比静态生成，需要更多的服务器资源。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3395b5f6fcc24c90b3ad594035f8b837" data-id="3395b5f6fcc24c90b3ad594035f8b837"><span><div id="3395b5f6fcc24c90b3ad594035f8b837" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3395b5f6fcc24c90b3ad594035f8b837" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-ab38b6ce42e140a59d99171f9c10b813"><li>首屏渲染速度快：由于页面的生成和呈现是在服务器端完成的，所以用户在访问页面时服务器可以返回已经渲染好的HTML，减少了浏览器的解析和渲染时间，从而可以更快地显示页面内容。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-8fcbe01380074ddfb7e56acdaf1e96cd"><li>SEO效果好：由于页面的内容在服务器端已经生成，所以搜索引擎爬虫可以直接获取到页面的内容，提高了网站的SEO排名。</li></ol><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-351564a79d9748c98df3f329fcb5f405" data-id="351564a79d9748c98df3f329fcb5f405"><span><div id="351564a79d9748c98df3f329fcb5f405" class="notion-header-anchor"></div><a class="notion-hash-link" href="#351564a79d9748c98df3f329fcb5f405" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-d39513ab17c742ed98aabd3f415e5a0b"><li>开发中的限制。浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-e1355b33d74b465ebe083c992d7e02ef"><li>更多的与构建配置和部署相关的要求。服务端渲染的应用需要一个能让 Node.js 服务器运行的环境，不像完全静态的 SPA 那样可以部署在任意的静态文件服务器上。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-cbc6c23e6ace4cc99604fc51ef01295c"><li>更高的服务端负载。在 Node.js 中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU 资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略。</li></ol><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-bfd0b32ca0a24e208f364dd109c30087" data-id="bfd0b32ca0a24e208f364dd109c30087"><span><div id="bfd0b32ca0a24e208f364dd109c30087" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bfd0b32ca0a24e208f364dd109c30087" title="增量渲染 ISR（Incremental Static Regeneration）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">增量渲染 ISR（Incremental Static Regeneration）</span></span></h2><div class="notion-text notion-block-eb1197d9bb4d410385e49c18131976b5">是一种介于静态生成和服务端渲染之间的解决方案。传统的预渲染如果需要更新内容就得将全部页面重新生成 HTML，而 <b>增量生成</b> 允许我们单独设置某一些页面重新生成据过期时，可以再次从 API 获取数据，并且生成静态页面，最适合常见的资讯类、新闻类网站。</div><div class="notion-blank notion-block-8ddb14cf142a44dc92577ccf17f20fa7"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-960f105c00c24a22b61c72174c3d4197" data-id="960f105c00c24a22b61c72174c3d4197"><span><div id="960f105c00c24a22b61c72174c3d4197" class="notion-header-anchor"></div><a class="notion-hash-link" href="#960f105c00c24a22b61c72174c3d4197" title="总结选择"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结选择</span></span></h3><table class="notion-simple-table notion-block-ffee50ca74ff4b22aba4f1a68a0ffeff"><tbody><tr class="notion-simple-table-row notion-block-3bb36cfc0d5441e7841b0acfba2fcc21"><td class="" style="width:120px"><div class="notion-simple-table-cell">ㅤ</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">CSR</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">SSR</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">SSG</div></td></tr><tr class="notion-simple-table-row notion-block-6ea469828f16405f839d2dd95ec1b326"><td class="" style="width:120px"><div class="notion-simple-table-cell">运行端</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">浏览器</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">服务器</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">服务器</div></td></tr><tr class="notion-simple-table-row notion-block-ab0bfaee2c394aa19b6e1f3b2d15a09c"><td class="" style="width:120px"><div class="notion-simple-table-cell">静态文件</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">单页面</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">由服务器即时生成</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">多个页面</div></td></tr><tr class="notion-simple-table-row notion-block-77bd6952c7e14218a0aa169e0026e892"><td class="" style="width:120px"><div class="notion-simple-table-cell">SEO</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">不适合</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">适合</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">适合</div></td></tr><tr class="notion-simple-table-row notion-block-adbf89e5a48249428549eba7187337ec"><td class="" style="width:120px"><div class="notion-simple-table-cell">静态文件CDN</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">适合</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">不适合</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">适合</div></td></tr><tr class="notion-simple-table-row notion-block-aaf7d50b8cc0489995873938a00523a7"><td class="" style="width:120px"><div class="notion-simple-table-cell">适用场景</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">中后台产品</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">信息展示型网站</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">内容较为固定的资讯类网站</div></td></tr></tbody></table><ul class="notion-list notion-list-disc notion-block-d6bf085b73c54844b424f01bd676cad3"><li>如果没有动态内容，可以使用静态页面生成 SSG。</li></ul><ul class="notion-list notion-list-disc notion-block-af8f4b17b67841e497e9bac489e81ec6"><li>如果有动态内容，但是动态内容和客户端相关，只能用客户端渲染 BSR。</li></ul><ul class="notion-list notion-list-disc notion-block-f7c897fb56dc482ea9d5af61ccee67b7"><li>如果有动态内容，且动态内容与请求/用户相关，可以使用服务端渲染 SSR 或 BSR。</li></ul><ul class="notion-list notion-list-disc notion-block-dec5a4852e634ad2b66fcbc40e2f55b1"><li>如果以上情况都不符合，可以使用 SSG 或 SSR 或 BSR。</li></ul><div class="notion-blank notion-block-429233a9849b4dd891890fd87288b806"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-62621b25c156477cae21a2d68997a8e4" data-id="62621b25c156477cae21a2d68997a8e4"><span><div id="62621b25c156477cae21a2d68997a8e4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#62621b25c156477cae21a2d68997a8e4" title="扩展"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">扩展</span></span></h2><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-bd1d70504c6c40bfa73aefeae0bafd98" href="https://juejin.cn/post/7233699680490799162?searchId=20231114162440816DDB7236A0B6FE29D2#heading-5"><div><div class="notion-bookmark-title">极速加载还是绝佳SEO？探索CSR、SSR、SSG等渲染模式的优劣对决 - 掘金</div><div class="notion-bookmark-description">近期的工作涉及到了CSR, SSR, SSG，这篇文章旨在总结和归纳这些渲染模式。 SPA、MPA、SSR 和 CSR 这几个词可能在你的工作生涯中经常出现，网上相关文章也很多。</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=bd1d7050-4c6c-40bf-a73a-efeae0bafd98" alt="极速加载还是绝佳SEO？探索CSR、SSR、SSG等渲染模式的优劣对决 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/7233699680490799162?searchId=20231114162440816DDB7236A0B6FE29D2#heading-5</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-9befa8e55959448e9183d2c0376c080b" href="https://cn.vuejs.org/guide/scaling-up/ssr.html#overview"><div><div class="notion-bookmark-title">Vue.js</div><div class="notion-bookmark-description">Vue.js - 渐进式的 JavaScript 框架</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://cn.vuejs.org/logo.svg?t=9befa8e5-5959-448e-9183-d2c0376c080b" alt="Vue.js" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://cn.vuejs.org/guide/scaling-up/ssr.html#overview</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="https://vuejs.org/images/logo.png?t=9befa8e5-5959-448e-9183-d2c0376c080b" alt="Vue.js" loading="lazy" decoding="async"/></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-4f7bccad79e34d9293dd95f481a779e8" href="https://juejin.cn/post/7241027834490437669"><div><div class="notion-bookmark-title">现代前端框架的渲染模式 - 掘金</div><div class="notion-bookmark-description">React 发布已经十年了，笔者接触前端差不多也有十年时间了。通过这篇文章，你就可以知道这快速发展的 10 年，前端渲染模式的演变和关系脉络，知其然，也知其所以然。</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=4f7bccad-79e3-4d92-93dd-95f481a779e8" alt="现代前端框架的渲染模式 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/7241027834490437669</div></div></div></a></div></main></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微前端总结]]></title>
        <id>https://tangly1024.com/article/2d953f41-cb77-42a0-8e51-b3f19844dcb6</id>
        <link href="https://tangly1024.com/article/2d953f41-cb77-42a0-8e51-b3f19844dcb6"/>
        <updated>2023-10-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<div id="notion-article" class="mx-auto overflow-hidden "><main class="notion light-mode notion-page notion-block-2d953f41cb7742a08e51b3f19844dcb6"><div class="notion-viewport"></div><div class="notion-collection-page-properties"></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-6bca6967b1944545a2466f1badaaf05d" data-id="6bca6967b1944545a2466f1badaaf05d"><span><div id="6bca6967b1944545a2466f1badaaf05d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6bca6967b1944545a2466f1badaaf05d" title="为什么要用微前端"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">为什么要用微前端</span></span></h2><div class="notion-text notion-block-8fc4063dfdd14263ae7715267a1b2ecf">微前端是一种架构理念，目的是<code class="notion-inline-code">将前端应用拆分为更小的、可独立开发和部署的模块</code>，<code class="notion-inline-code">每个模块</code>都可以<code class="notion-inline-code">由不同的团队</code>进行<code class="notion-inline-code">开发和维护</code>。在合理拆分应用的前提下，微前端能降低应用之间的耦合度，提升每个团队的自治能力。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-483c2436138b40f6831e70bb2c4e30b2" data-id="483c2436138b40f6831e70bb2c4e30b2"><span><div id="483c2436138b40f6831e70bb2c4e30b2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#483c2436138b40f6831e70bb2c4e30b2" title="基本原理"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">基本原理</span></span></h2><div class="notion-text notion-block-e1653548ff3648cdae5636c957c5d534">当路由切换的时候，可以去加载对应应用的Entry，让其跑在容器里</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-a2bfdcbc7d444d0d95f51ff3f0374df9" data-id="a2bfdcbc7d444d0d95f51ff3f0374df9"><span><div id="a2bfdcbc7d444d0d95f51ff3f0374df9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a2bfdcbc7d444d0d95f51ff3f0374df9" title="解决痛点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">解决痛点</span></span></h2><ul class="notion-list notion-list-disc notion-block-7b916af1fb514d56bed4089fe66ea557"><li>新老项目技术栈不同，很难集成</li></ul><ul class="notion-list notion-list-disc notion-block-d8aa8f7ec8b64c38a75ebda8db3b0b80"><li>多页应用跳转体验不好，要重新刷新</li></ul><ul class="notion-list notion-list-disc notion-block-50be0b0f4cfc46aca732c047d0a2b198"><li>项目体量大，小改动就要全量打包。容易出现冲突。打包慢、启动慢、定位慢。</li></ul><ul class="notion-list notion-list-disc notion-block-f80016005568430485ab843af278ff27"><li>项目体量大，由多个团队维护，容易出现冲突</li></ul><ul class="notion-list notion-list-disc notion-block-bd296cc0fdb0461383facfbc018b3073"><li>基于多页的子应用缺乏管理，规范/标准不统一。无法统一控制视觉呈现、共享的功能和依赖。造成重复工作</li></ul><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-6df153c38427468383359b4e0eaa360f" data-id="6df153c38427468383359b4e0eaa360f"><span><div id="6df153c38427468383359b4e0eaa360f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6df153c38427468383359b4e0eaa360f" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h2><ul class="notion-list notion-list-disc notion-block-973f8847d5f54b0f8e5f53f213863596"><li>技术栈无关、更容易老旧系统的集成</li></ul><ul class="notion-list notion-list-disc notion-block-d1aaa6fc5ef94dd784cf602a15cb9bed"><li>切换应用不需要重新刷新页面，只需要卸载旧子应用，加载新子应用</li></ul><ul class="notion-list notion-list-disc notion-block-b0e4a00da2a14791b5ab11b82a33a68f"><li>每个模块可以独立部署上线，互不干扰。</li></ul><ul class="notion-list notion-list-disc notion-block-b03a5b461dc74173ae8c1698e8031206"><li>可以拥有独立的仓库，可以由独立的团队开发维护，独立部署升级。</li></ul><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-ee6c413ccbe24b2e95623b04952810e2" data-id="ee6c413ccbe24b2e95623b04952810e2"><span><div id="ee6c413ccbe24b2e95623b04952810e2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ee6c413ccbe24b2e95623b04952810e2" title="微服务功能设计"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">微服务功能设计</span></span></h2><div class="notion-blank notion-block-9d9e54107581491984c035fa3c349d40"> </div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-40fd2712c4dd41cfbc149a9badb1d468"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fde5ea524-b729-4eea-845e-59eaf20e7149%2F41e4e147-5d97-45c1-b3f1-e2f29ce7354b%2FUntitled.png?table=block&amp;id=40fd2712-c4dd-41cf-bc14-9a9badb1d468&amp;t=40fd2712-c4dd-41cf-bc14-9a9badb1d468&amp;width=1921&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-1f6ebf8ab728471d80c9ff9af6543a0a"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fde5ea524-b729-4eea-845e-59eaf20e7149%2F9d497377-8ecd-4ec4-96a5-1be081aa6ede%2FUntitled.png?table=block&amp;id=1f6ebf8a-b728-471d-80c9-ff9af6543a0a&amp;t=1f6ebf8a-b728-471d-80c9-ff9af6543a0a&amp;width=1394&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-266871042ac94f96be05077a60e67488" data-id="266871042ac94f96be05077a60e67488"><span><div id="266871042ac94f96be05077a60e67488" class="notion-header-anchor"></div><a class="notion-hash-link" href="#266871042ac94f96be05077a60e67488" title="实现微前端的方式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">实现微前端的方式</span></span></h3><ul class="notion-list notion-list-disc notion-block-dd46ef25981e448fbdfe84100695adb8"><li>使用 HTTP 服务器的路由来重定向多个应用</li></ul><ul class="notion-list notion-list-disc notion-block-150440c90520478f8ee454e9e143a2dc"><li>在不同的框架之上设计通讯、加载机制</li></ul><ul class="notion-list notion-list-disc notion-block-69ad12e224734b6ab4cc516a662cd367"><li>通过组合多个独立应用、组件来构建一个单体应用</li></ul><ul class="notion-list notion-list-disc notion-block-7c1970ba2a8842e5bc8585fa6b79aee2"><li>iFrame。使用 iFrame 及自定义消息传递机制</li></ul><ul class="notion-list notion-list-disc notion-block-4af7b6c1b6934734a5017bec8f3d8058"><li>使用纯 Web Components 构建应用</li></ul><ul class="notion-list notion-list-disc notion-block-23f7c76bb8ab40168fd9e2f35c73bb87"><li>结合 Web Components 构建</li></ul><ul class="notion-list notion-list-disc notion-block-1fc9653026dc476e9224e76ac8e8a8e1"><li>利用webpack5的联邦模块</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-5e4619cb23e24c62b7dd1e4bb16cac81"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fde5ea524-b729-4eea-845e-59eaf20e7149%2F77700565-f8e0-4122-908d-68803b1649a7%2FUntitled.png?table=block&amp;id=5e4619cb-23e2-4c62-b7dd-1e4bb16cac81&amp;t=5e4619cb-23e2-4c62-b7dd-1e4bb16cac81&amp;width=1394&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><div class="notion-blank notion-block-2ee873fdd7644b37be72805b769e3f2c"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-d2632d635cc9445aa03c115befaf88d5" data-id="d2632d635cc9445aa03c115befaf88d5"><span><div id="d2632d635cc9445aa03c115befaf88d5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d2632d635cc9445aa03c115befaf88d5" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-fdf612a0b29a45a3a29c6ed83ebc6df1"><li><b>性能问题：</b> 如果不同的微前端应用使用了不同的库或框架，可能会导致加载和运行的性能问题。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-504ffd02e2f84da8a401dde6291fe25e"><li><b>一致性：</b> 保持不同的微前端应用在用户体验、设计和行为上的一致性可能会比较困难。一般引入微前端后，都需要对导航栏进行改造，使用宿主应用导航栏。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-c6ad12300f1c4588b0513d815dcf0cf2"><li><b>状态共享：</b> 在微前端应用之间共享状态可能会比较复杂，需要使用特殊的工具或模式。</li></ol><ol start="4" class="notion-list notion-list-numbered notion-block-78faaeba3ba54e50b7bce353f7dc0233"><li><b>复杂性：</b> 尽管微前端可以解决大型项目的复杂性问题，但是它自身也带来了一些复杂性，比如需要管理和协调多个独立的应用，避免每个应用的路由冲突，如何共用一些通用的依赖库，如何解决js、css隔离。</li></ol><ol start="5" class="notion-list notion-list-numbered notion-block-5ee12e95824c4a4594583c744359daa9"><li><b>安全性：</b> 微前端架构可能会增加跨域等安全问题。</li></ol><div class="notion-text notion-block-d2d87f3768cd4299b577e307912882b8">目前市面有各类不同的微前端方案，但没有完美的解决方案。微前端方案通常需要考虑：应用加载机制、通信机制、代码隔离机制等问题。</div><div class="notion-blank notion-block-754e8f32ec7844f98c590bb6cf882364"> </div><div class="notion-blank notion-block-34387b07fc5b440380e985b0d1810a78"> </div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-5a62e685d33043878c9f67af37eba616"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fde5ea524-b729-4eea-845e-59eaf20e7149%2F340e726d-73b4-4253-8903-c8ac72c75f6b%2FUntitled.png?table=block&amp;id=5a62e685-d330-4387-8c9f-67af37eba616&amp;t=5a62e685-d330-4387-8c9f-67af37eba616&amp;width=783&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><div class="notion-blank notion-block-8345b930e51f425c9244a2247fc59985"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-0cf4dc5f6405427491e2ee00d1631532" data-id="0cf4dc5f6405427491e2ee00d1631532"><span><div id="0cf4dc5f6405427491e2ee00d1631532" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0cf4dc5f6405427491e2ee00d1631532" title="工程化问题"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">工程化问题</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-04b2ea0bddf84fba97db5e35f1429374" data-id="04b2ea0bddf84fba97db5e35f1429374"><span><div id="04b2ea0bddf84fba97db5e35f1429374" class="notion-header-anchor"></div><a class="notion-hash-link" href="#04b2ea0bddf84fba97db5e35f1429374" title="共享"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">共享</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-7440280a16464552b1baec2ca435d316"><li>工具共享</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-d61bbaf6674c4ce5a69aa099644e3a77"><li>状态共享</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-41fa5a226e4847188970b03f334529a7"><li>依赖共享</li></ol><ol start="4" class="notion-list notion-list-numbered notion-block-e339bf47e0f84db48bfa5826fa5ca3d8"><li>消息通信</li></ol><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-560d31d55d244ab8ba9b6275d3d6133e" data-id="560d31d55d244ab8ba9b6275d3d6133e"><span><div id="560d31d55d244ab8ba9b6275d3d6133e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#560d31d55d244ab8ba9b6275d3d6133e" title="隔离"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">隔离</span></span></h3><ul class="notion-list notion-list-disc notion-block-0b8210dbba904652b6c5dc3847ca7e84"><li>样式隔离</li></ul><ul class="notion-list notion-list-disc notion-block-90a2ee6ad6dd4952b9bf50f016046a23"><li>js隔离，全局变量和事件</li></ul><ul class="notion-list notion-list-disc notion-block-051f914ca93b495f9fffa9718d0e196a"><li>storage隔离</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-152f319560e94b7ea7b399198b8a3e9e" data-id="152f319560e94b7ea7b399198b8a3e9e"><span><div id="152f319560e94b7ea7b399198b8a3e9e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#152f319560e94b7ea7b399198b8a3e9e" title="通信"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">通信</span></span></h3><ul class="notion-list notion-list-disc notion-block-afa6b9b38cf945b7a9a12ff4f26ddd40"><li>父子通信</li></ul><ul class="notion-list notion-list-disc notion-block-4d2cb17eade54af29f498027a7386217"><li>子子通信</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-9fc79da7823a4db9b3fc7aa9386f4c89" data-id="9fc79da7823a4db9b3fc7aa9386f4c89"><span><div id="9fc79da7823a4db9b3fc7aa9386f4c89" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9fc79da7823a4db9b3fc7aa9386f4c89" title="性能"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">性能</span></span></h3><ul class="notion-list notion-list-disc notion-block-b91109f05567485a88bd09e7b9467c52"><li>按需加载</li></ul><ul class="notion-list notion-list-disc notion-block-0f196a32ec974cacbd32d215e76a4606"><li>预加载</li></ul><ul class="notion-list notion-list-disc notion-block-973adea4736a4aefae2e7d8c80d576ba"><li>多子应用共存、子应用嵌套</li></ul><ul class="notion-list notion-list-disc notion-block-b41ce7f46e6b4ffd94fbc6cb99e81b31"><li>缓存子应用</li></ul><ul class="notion-list notion-list-disc notion-block-a641707eb2914f4583a011cef911c4c3"><li>tree-sharking</li></ul><div class="notion-blank notion-block-37b6a1e386c9487ab306fc118bf73b44"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-68fc1fb611f64a8d8486dedee695bf3f" data-id="68fc1fb611f64a8d8486dedee695bf3f"><span><div id="68fc1fb611f64a8d8486dedee695bf3f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#68fc1fb611f64a8d8486dedee695bf3f" title="基座应用功能"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">基座应用功能</span></span></h2><ul class="notion-list notion-list-disc notion-block-237a9fe814c14e0abb65834733b9abeb"><li>权限控制</li></ul><ul class="notion-list notion-list-disc notion-block-0580a93680d74a7688cec53527905030"><li>路由控制</li></ul><ul class="notion-list notion-list-disc notion-block-6941f76607a2441f9b9a2fe2b5844135"><li>全局方法注入</li></ul><ul class="notion-list notion-list-disc notion-block-360879cc55ab45079cf6000768770d13"><li>异常处理</li></ul><ul class="notion-list notion-list-disc notion-block-1a8e287f78064f55aa3f93a7db0a68f1"><li>菜单空盒子</li></ul><ul class="notion-list notion-list-disc notion-block-1e67547835314695894e12503bfd5d1f"><li>请求拦截，处理异常状态码，如果监听到 401 状态码，则跳转到登录页面进行授权。</li></ul><ul class="notion-list notion-list-disc notion-block-3b0df2dc47b44dc59a6fe57abf3c7f49"><li>全局样式，例如主题色</li></ul><ul class="notion-list notion-list-disc notion-block-fefa67c72e394579b51987ddd1327088"><li>状态管理</li></ul><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-6ec02aeebda34dea8a7dad60c5cd96e4" data-id="6ec02aeebda34dea8a7dad60c5cd96e4"><span><div id="6ec02aeebda34dea8a7dad60c5cd96e4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6ec02aeebda34dea8a7dad60c5cd96e4" title="子应用注入方式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">子应用注入方式</span></span></h2><div class="notion-text notion-block-9e14059482f646b080f9de8a9c870ef8">Entry 用于父应用引入子应用相应的资源文件（包括 <code class="notion-inline-code">JS</code>、<code class="notion-inline-code">CSS</code>），主要分为两种方式：</div><ul class="notion-list notion-list-disc notion-block-97a47c2106bb42a8817258183588d7cb"><li>JS Entry</li></ul><ul class="notion-list notion-list-disc notion-block-9b8938339f5e4d14a60097aae5cd8f2c"><li>HTML Entry</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-86838e243ca741beaa700e0f60bb916f" data-id="86838e243ca741beaa700e0f60bb916f"><span><div id="86838e243ca741beaa700e0f60bb916f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#86838e243ca741beaa700e0f60bb916f" title="JS Entry 方式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">JS Entry 方式</span></span></h3><div class="notion-text notion-block-e5571980bb7545d4b27c96dfe8545511">JS Entry 的原理是：</div><ol start="1" class="notion-list notion-list-numbered notion-block-6d7174bd1d00468f95cfcef77a11996d"><li>把 <code class="notion-inline-code">CSS</code> 打包进 <code class="notion-inline-code">JS</code>，生成一个 <code class="notion-inline-code">manifest.json</code> 配置文件</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-628ec7dd32c54aa793590c6d73ddabac"><li><code class="notion-inline-code">manifest.json</code> 中标识了子应用资源文件的相对路径地址</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-77077cacb55742e39d232360df57429e"><li>主应用通过插入 <code class="notion-inline-code">script</code> 标签 <code class="notion-inline-code">src</code> 属性的方式加载子应用资源文件（子应用域名 + <code class="notion-inline-code">manifest.json</code> 中的相对路径地址）</li></ol><div class="notion-text notion-block-6cf69b0b0f2d4c0da8427d8b43026563">基于这样的原理，因此 JS Entry 有缺陷：</div><ul class="notion-list notion-list-disc notion-block-4c0986adc49644a8955f37d6c9e73ec2"><li>打包时，需要额外对工程化代码做修改，生成一份资源配置文件 <code class="notion-inline-code">manifest.json</code> 给主应用加载</li></ul><ul class="notion-list notion-list-disc notion-block-0c8c218b89b148ae85a7313b38399526"><li>打包时，需要额外对样式打包做修改，需要把 <code class="notion-inline-code">CSS</code> 打包进 <code class="notion-inline-code">JS</code> 中，也增加了编译后的包体积</li></ul><ul class="notion-list notion-list-disc notion-block-9a1fc2c62b8b476da723fd7635b3dd9c"><li>打包时，不能在 <code class="notion-inline-code">html</code> 中插入行内 <code class="notion-inline-code">script</code> 代码。因为 <code class="notion-inline-code">manifest.json</code> 中只能存放地址路径。因此要禁止 <code class="notion-inline-code">webpack</code> 把配置代码直接打入 <code class="notion-inline-code">html</code> 中</li></ul><ul class="notion-list notion-list-disc notion-block-ccfff3ee7caa44b8b5ebeb2acbfe9e2f"><li>父子应用域名不一致，父应用加载子应用 <code class="notion-inline-code">manifest.json</code> 会发生跨域，需要额外处理</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-9d0cf426d43e486fbf8d703081933cd6" data-id="9d0cf426d43e486fbf8d703081933cd6"><span><div id="9d0cf426d43e486fbf8d703081933cd6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9d0cf426d43e486fbf8d703081933cd6" title="HTML Entry 方式"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">HTML Entry 方式</span></span></h3><div class="notion-text notion-block-2acd24d0c2f14ba68d7c48b8f2bab3f9">HTML Entry 是利用 <code class="notion-inline-code">import-html-entry</code> 直接获取子应用 <code class="notion-inline-code">html</code> 文件，解析 <code class="notion-inline-code">html</code> 文件中的资源加载入主应用</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-bb51934dcd7642d385fd3eb6ca1c9656" data-id="bb51934dcd7642d385fd3eb6ca1c9656"><span><div id="bb51934dcd7642d385fd3eb6ca1c9656" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bb51934dcd7642d385fd3eb6ca1c9656" title="HTML Entry 优于 JS Entry 的地方"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">HTML Entry 优于 JS Entry 的地方</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-3eddea7e628842aeb009973f87c13331"><li>不用生成额外的 <code class="notion-inline-code">manifest.json</code></li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-577f435b9b65449796889f0716e2c3e4"><li>不用把 <code class="notion-inline-code">css</code> 打包进 <code class="notion-inline-code">js</code> 中</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-91e8c4aa40554f0faa319c3478b37f0a"><li>全局 <code class="notion-inline-code">css</code> 独立打包，不会冗余</li></ol><ol start="4" class="notion-list notion-list-numbered notion-block-666cafc117c540c0b492b9581b885b9b"><li>不使用生成 <code class="notion-inline-code">script</code> 的方式插入子应用 <code class="notion-inline-code">JS</code> 代码，不会生成额外的 <code class="notion-inline-code">DOM</code> 节点</li></ol><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-2146ac96be0745e2a920d710e08f3745" data-id="2146ac96be0745e2a920d710e08f3745"><span><div id="2146ac96be0745e2a920d710e08f3745" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2146ac96be0745e2a920d710e08f3745" title="微前端方案"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">微前端方案</span></span></h2><ul class="notion-list notion-list-disc notion-block-f864e805108247f79d4639b6a7fb37f3"><li>iframe（天然的微前端方案，但是弊端很多）</li></ul><ul class="notion-list notion-list-disc notion-block-b1f9fe21a4e643f3bb472f862ed9ec29"><li>single-spa</li></ul><ul class="notion-list notion-list-disc notion-block-4a218c6803d7404881de3e6bd1025145"><li>web components（最适合但是兼容性最差）</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-40d4231bdc294359aea1c71141261e8c" data-id="40d4231bdc294359aea1c71141261e8c"><span><div id="40d4231bdc294359aea1c71141261e8c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#40d4231bdc294359aea1c71141261e8c" title="iframe "><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">iframe </span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-9af91a850d6b4863a41cd7fafb05947c" data-id="9af91a850d6b4863a41cd7fafb05947c"><span><div id="9af91a850d6b4863a41cd7fafb05947c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9af91a850d6b4863a41cd7fafb05947c" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h4><ul class="notion-list notion-list-disc notion-block-ad058eb790fd43b8b800e911faa48ce6"><li>浏览器原生的硬隔离方案，改造成本低</li></ul><ul class="notion-list notion-list-disc notion-block-f1a1b3cbab284780a090a11b06f3670d"><li>天然支持 <code class="notion-inline-code">CSS</code> 隔离、<code class="notion-inline-code">JS</code> 隔离</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-de53d434fb024c76bee53bae640c71d1" data-id="de53d434fb024c76bee53bae640c71d1"><span><div id="de53d434fb024c76bee53bae640c71d1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#de53d434fb024c76bee53bae640c71d1" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h4><ul class="notion-list notion-list-disc notion-block-4be7a577e5bc4af6b8df412bd429de12"><li>URL 不同步</li><ul class="notion-list notion-list-disc notion-block-4be7a577e5bc4af6b8df412bd429de12"><li><code class="notion-inline-code">iframe</code> 内部页面跳转，<code class="notion-inline-code">url</code> 不会更新</li><li>浏览器刷新导致 <code class="notion-inline-code">iframe url</code> 状态丢失、后退前进按钮无法使用。</li></ul></ul><ul class="notion-list notion-list-disc notion-block-af4b62d97af5450a912aad9b2b109192"><li>UI 不同步</li><ul class="notion-list notion-list-disc notion-block-af4b62d97af5450a912aad9b2b109192"><li><code class="notion-inline-code">DOM</code> 结构不共享。<code class="notion-inline-code">iframe</code> 里的弹窗遮罩无法在整个父应用上覆盖</li></ul></ul><ul class="notion-list notion-list-disc notion-block-b6161c283db2477c9d8b9e13be1540f9"><li>全局上下文完全隔离，内存变量不共享。<code class="notion-inline-code">iframe</code> 内外系统的通信、数据同步等需求，主应用的 <code class="notion-inline-code">cookie</code> 要透传到根域名都不同的子应用中实现免登效果。</li></ul><ul class="notion-list notion-list-disc notion-block-a196f35c65b54d46a3c88aa4f24263ce"><li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。</li></ul><ul class="notion-list notion-list-disc notion-block-725c72b930b0411c8adff4df4c3d00c8"><li>无法共享基础库进一步减少包体积</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-70b54f78d0d4410a83dc93dcf7a71fcd" data-id="70b54f78d0d4410a83dc93dcf7a71fcd"><span><div id="70b54f78d0d4410a83dc93dcf7a71fcd" class="notion-header-anchor"></div><a class="notion-hash-link" href="#70b54f78d0d4410a83dc93dcf7a71fcd" title="qiankun（single-spa）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">qiankun（single-spa）</span></span></h3><div class="notion-text notion-block-c4edfc9f56234de0a785ae1e3a8be2d0">single-spa原理：<b>监听路由+卸货+装货，qiankun</b> 是对 <code class="notion-inline-code">single-spa</code> 的一层封装</div><div class="notion-text notion-block-8dfe6c6da964467ab0eff3fd93cb1b7e">核心做了构建层面的一些约束以及沙箱能力，支持多子应用并存，但是接入的修改成本较高，总的来说算是目前比较<b>优选的微前端框架。</b></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-38190ab0c6f649d085171c536ed75383" data-id="38190ab0c6f649d085171c536ed75383"><span><div id="38190ab0c6f649d085171c536ed75383" class="notion-header-anchor"></div><a class="notion-hash-link" href="#38190ab0c6f649d085171c536ed75383" title="原理"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">原理</span></span></h4><div class="notion-text notion-block-7882c3bed41e4b009cb7448c03971493"><b>应用加载</b>：qiankun 通过动态创建 script 标签的方式加载子应用的入口文件。加载完成后，会执行子应用暴露出的生命周期函数。</div><div class="notion-text notion-block-b32343ec5bd24fc4bb2570c31a7fe4a2"><b>生命周期管理</b>：qiankun 要求每个子应用都需要暴露出 bootstrap、mount 和 unmount 三个生命周期函数。bootstrap 函数在应用加载时被调用，mount 函数在应用启动时被调用，unmount 函数在应用卸载时被调用。</div><div class="notion-text notion-block-58255e3653984e54be49d0d82136cc50"><b>沙箱隔离</b>：qiankun 通过 Proxy 对象创建了一个 JavaScript 沙箱，用于隔离子应用的全局变量，防止子应用之间的全局变量污染。</div><div class="notion-text notion-block-1175903c6b0a4fa3ada40bc7740cf9a4"><b>样式隔离</b>：qiankun 通过动态添加和移除样式标签的方式实现了样式隔离。当子应用启动时，会动态添加子应用的样式标签，当子应用卸载时，会移除子应用的样式标签。</div><div class="notion-text notion-block-e88079cbe0fe4069a7c1a0682f39f719"><b>通信机制</b>：qiankun 提供了一个全局的通信机制，允许子应用之间进行通信。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-0584c83e9c634aee8eae7a8912efc1bd" data-id="0584c83e9c634aee8eae7a8912efc1bd"><span><div id="0584c83e9c634aee8eae7a8912efc1bd" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0584c83e9c634aee8eae7a8912efc1bd" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>优点</b></span></span></h4><ul class="notion-list notion-list-disc notion-block-a630598f99a944a088152ca61719c5e1"><li>降低了应用改造的成本，通过html entry的方式引入子应用；</li></ul><ul class="notion-list notion-list-disc notion-block-be0fee9d47f74425974d4374e9eb163e"><li>完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了 strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案；</li></ul><ul class="notion-list notion-list-disc notion-block-5e02b1d701bb412a9a7511d08266290f"><li>支持静态资源预加载能力。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-9a738690f9d941e4917bb28099c730ff" data-id="9a738690f9d941e4917bb28099c730ff"><span><div id="9a738690f9d941e4917bb28099c730ff" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9a738690f9d941e4917bb28099c730ff" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>缺点</b></span></span></h4><ul class="notion-list notion-list-disc notion-block-6fe34bd0251044a09282f20db694c63a"><li>适配成本较高，包括工程化、生命周期、静态资源路径、路由等方面的适配；</li></ul><ul class="notion-list notion-list-disc notion-block-61718b32cdb2433d8af3505df7234339"><li>css沙箱的严格隔离可能引发问题，js沙箱在某些场景下执行性能下降；</li></ul><ul class="notion-list notion-list-disc notion-block-e9a8077a1cbd45f2bf4d65916323cf43"><li>无法同时激活多个子应用，不支持子应用保活；</li></ul><ul class="notion-list notion-list-disc notion-block-f4961b4b17cc4c3e9c0022dd09736f58"><li>不支持vite等esmodule脚本运行。</li></ul><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-29dfa347db21418cbd3bb6e5c810b43a" href="https://segmentfault.com/a/1190000042738311"><div><div class="notion-bookmark-title">segmentfault.com</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-text">https://segmentfault.com/a/1190000042738311</div></div></div></a></div><div class="notion-blank notion-block-97ae24c449374a02b4096d85631138df"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-2e07110016094a728a48ddeecacd22e8" data-id="2e07110016094a728a48ddeecacd22e8"><span><div id="2e07110016094a728a48ddeecacd22e8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2e07110016094a728a48ddeecacd22e8" title="无界"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">无界</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-e7824361338044ca97dd089fd2174c89" data-id="e7824361338044ca97dd089fd2174c89"><span><div id="e7824361338044ca97dd089fd2174c89" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e7824361338044ca97dd089fd2174c89" title="原理"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">原理</span></span></h4><div class="notion-text notion-block-953ef52104064d80814f9207c2288f8b"><b>css隔离</b>：将子应用的 dom 放置在 webcomponent + shadowdom 的容器中，除了可继承的 css 属性外实现了应用之间 css 的原生隔离。</div><div class="notion-text notion-block-b278f3b6a15c49e89a4e791d38f9c8fe"><b>js隔离</b>：子应用的 js 在 iframe 内运行</div><div class="notion-text notion-block-afb9beb22bb349fdb2145aea960f3e78"><b>js 沙箱和 css 沙箱连接</b>：无界在底层采用 proxy + Object.defineproperty 的方式将 js-iframe 中对 dom 操作劫持代理到 webcomponent shadowRoot 容器中，开发者无感知也无需关心。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-0deef736b3404d7680d973be0201e515" data-id="0deef736b3404d7680d973be0201e515"><span><div id="0deef736b3404d7680d973be0201e515" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0deef736b3404d7680d973be0201e515" title="优点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">优点</span></span></h4><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-06270a61015d47c18b7cdf7fa0e4a763" data-id="06270a61015d47c18b7cdf7fa0e4a763"><span><div id="06270a61015d47c18b7cdf7fa0e4a763" class="notion-header-anchor"></div><a class="notion-hash-link" href="#06270a61015d47c18b7cdf7fa0e4a763" title="缺点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">缺点</span></span></h3><ol start="1" class="notion-list notion-list-numbered notion-block-20de9bcb193f441198cf202ab07592f3"><li>要单独开iframe作为js沙箱，内存占用大。</li></ol><div class="notion-blank notion-block-7fd9808775204124bb0b781e063d6fcc"> </div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-c99d508429d44beab31547e73258e3d8" href="https://juejin.cn/post/7221366548077707321"><div><div class="notion-bookmark-title">微前端：乾坤 VS 无界 - 掘金</div><div class="notion-bookmark-description">共同点： 当路由切换的时候，可以去加载对应应用的代码，让其跑在容器里。 差异点： 容器实现方案不同。</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=c99d5084-29d4-4bea-b315-47e73258e3d8" alt="微前端：乾坤 VS 无界 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/7221366548077707321</div></div></div></a></div><div class="notion-blank notion-block-882865cd19c34e6d984ce00b7083c3c7"> </div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-a6079c3a742f4f99863a744890d95273" href="https://zhuanlan.zhihu.com/p/442815952"><div><div class="notion-bookmark-title">让iframe焕发新生</div><div class="notion-bookmark-description">作者：damyxu，腾讯 PCG 前端开发工程师 背景前端开发中我们对 iframe已经非常熟悉了，那么iframe的作用是什么？可以归纳如下：在一个 web应用中可以独立的运行另一个web应用这个概念已经和 微前端不谋而合，相对…</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png?t=a6079c3a-742f-4f99-863a-744890d95273" alt="让iframe焕发新生" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://zhuanlan.zhihu.com/p/442815952</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="https://pica.zhimg.com/v2-ff0489265e959b8c3fd438f5fa94ad51_720w.jpg?source=172ae18b&amp;t=a6079c3a-742f-4f99-863a-744890d95273" alt="让iframe焕发新生" loading="lazy" decoding="async"/></div></a></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-daa97496c863415192ccbbbc6b3b8570" data-id="daa97496c863415192ccbbbc6b3b8570"><span><div id="daa97496c863415192ccbbbc6b3b8570" class="notion-header-anchor"></div><a class="notion-hash-link" href="#daa97496c863415192ccbbbc6b3b8570" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h3><div class="notion-text notion-block-8ab1d13144274fdf91c5ffbed3c1fe61"><code class="notion-inline-code">qiankun</code> 是基于 <code class="notion-inline-code">single-spa</code> 的微前端解决方案，它通过 JavaScript 的 <code class="notion-inline-code">import</code> 功能动态加载子应用，然后在主应用的 DOM 中挂载子应用的 DOM。<code class="notion-inline-code">qiankun</code> 提供了一种 JavaScript 沙箱机制，可以隔离子应用的全局变量，防止子应用之间的全局变量污染。此外，<code class="notion-inline-code">qiankun</code> 还提供了一种样式隔离机制，可以防止子应用的 CSS 影响其他应用。这些特性使得 <code class="notion-inline-code">qiankun</code> 在处理复杂的微前端场景时具有很高的灵活性。</div><div class="notion-text notion-block-98e6441e054b42bebb47986a638e3f39"><code class="notion-inline-code">iframe</code> 是一种较为传统的前端技术，它可以在一个独立的窗口中加载一个 HTML 页面。<code class="notion-inline-code">iframe</code> 本身就是一种天然的沙箱，它可以完全隔离子应用的 JavaScript 和 CSS，防止子应用之间的相互影响。然而，<code class="notion-inline-code">iframe</code> 的这种隔离性也是它的缺点，因为它使得主应用和子应用之间的通信变得困难。此外，<code class="notion-inline-code">iframe</code> 还有一些其他的问题，比如性能问题、SEO 问题等。</div><div class="notion-text notion-block-f741b4157d954457a11f490b863aaafa">在选择 <code class="notion-inline-code">qiankun</code> 和 <code class="notion-inline-code">iframe</code> 时，需要根据具体的使用场景来决定。如果你的子应用是基于现代前端框架（如 React、Vue、Angular 等）开发的单页应用，那么 <code class="notion-inline-code">qiankun</code> 可能是一个更好的选择，因为它可以提供更好的用户体验和更高的开发效率。如果你的子应用是基于 jQuery 或者其他传统技术开发的多页应用，或者你需要在子应用中加载一些第三方的页面，那么 <code class="notion-inline-code">iframe</code> 可能是一个更好的选择，因为它可以提供更强的隔离性。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-371e3d650dd249abb5d53accd31e8f20" data-id="371e3d650dd249abb5d53accd31e8f20"><span><div id="371e3d650dd249abb5d53accd31e8f20" class="notion-header-anchor"></div><a class="notion-hash-link" href="#371e3d650dd249abb5d53accd31e8f20" title="核心能力"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>核心能力</b></span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-2ab9a6ab376f403c924c2b72927cefbc" data-id="2ab9a6ab376f403c924c2b72927cefbc"><span><div id="2ab9a6ab376f403c924c2b72927cefbc" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2ab9a6ab376f403c924c2b72927cefbc" title="路由管理"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>路由管理</b></span></span></h3><div class="notion-text notion-block-24c44e5a24dc47baad7950b277cefa1b">一般我们使用 Hash 或者 History 模式来对路由进行监听，如 hashchange 或 popstate 事件。</div><div class="notion-text notion-block-3025dd570bc44962b1f2642cf13188df">目前常见的微前端解决方案主要是路由驱动的。在微前端的基座，进行子应用的路由注册，如 <code class="notion-inline-code">{ path: &#x27;/microA/*&#x27; }</code> ，基座根据路由匹配情况，按需挂载子应用。具体路由跳转规则由子应用接管响应。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3823ebbe0803495392bd8015281a0d84" data-id="3823ebbe0803495392bd8015281a0d84"><span><div id="3823ebbe0803495392bd8015281a0d84" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3823ebbe0803495392bd8015281a0d84" title="隔离机制"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>隔离机制</b></span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-67c35fb6348c48a6b35eb3405bc6f604" data-id="67c35fb6348c48a6b35eb3405bc6f604"><span><div id="67c35fb6348c48a6b35eb3405bc6f604" class="notion-header-anchor"></div><a class="notion-hash-link" href="#67c35fb6348c48a6b35eb3405bc6f604" title="css隔离"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">css隔离</span></span></h4><ol start="1" class="notion-list notion-list-numbered notion-block-234c77a977094e88be86f8384758fb3b"><li>动态样式表，应用卸载之后样式也同时卸载；这种方式需要注意的问题是微应用卸载时也要通知主应用将微应用的样式卸载掉，如果卸载不成功则会造成样式污染</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-aa02b06aefd94203b35678993dc17a3c"><li>工程化手段：css module，css in js，无法杜绝项目中使用全局样式，可能需要我们约定只能在主应用中修改全局组件样式</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-42f818da6a35410ca5022cfc1a27b95a"><li>shadow DOM，天然的样式隔离</li></ol><ol start="4" class="notion-list notion-list-numbered notion-block-dc8f7d314b1d4e7598c140fe229758cb"><li>运行时样式转换：运行时给所有节点增加一个属性，利用属性选择器创建命名空间<code class="notion-inline-code">div[data-qiankun-subvue1]</code></li></ol><ol start="5" class="notion-list notion-list-numbered notion-block-fc1ca50cc2954af7b8da4d61f2bf82cb"><li>BEM约束，或者编译时增加namespace</li></ol><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-1224590122cb4eba980822cab88bd675" data-id="1224590122cb4eba980822cab88bd675"><span><div id="1224590122cb4eba980822cab88bd675" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1224590122cb4eba980822cab88bd675" title="js隔离"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">js隔离</span></span></h4><div class="notion-text notion-block-407b75bfca73441cb7569d800c11ab8d"><b>快照沙箱</b></div><div class="notion-text notion-block-105c608a3d0845c98f485bd3f758bb50">在沙箱激活时，记录window当时的状态作为快照，在沙箱卸载时，恢复快照。</div><div class="notion-text notion-block-dd6a1db2263f4712b202a2e319445407">缺点：</div><ul class="notion-list notion-list-disc notion-block-8ade5333514348d7a791f6eaf9823e3f"><li> 会改变全局window的属性，如果同时运行多个微应用，多个应用同时改写window上的属性。所以只能在单个子应用模式下使用。</li></ul><ul class="notion-list notion-list-disc notion-block-f918ff2a9da94878a7448dc058fa4880"><li>会通过<code class="notion-inline-code">for(prop in window){}</code>的方式来遍历window上的所有属性，window属性众多，很耗费性能。</li></ul><div class="notion-text notion-block-fd20635b87b945c08300453eb99fea22"><b>代理沙箱</b></div><div class="notion-text notion-block-b54b3ec852f64dd6a41744dc9951a248">在激活时，利用 <code class="notion-inline-code">proxy API</code>  代理window属性，记录属性的修改，在沙箱卸载时，恢复修改的属性。</div><div class="notion-text notion-block-ae736bf953b94377b93626a202fb0973">缺点：</div><ul class="notion-list notion-list-disc notion-block-8a87a77d363e423aa4f125c4f42bb98b"><li>会改变全局window的属性，如果同时运行多个微应用，多个应用同时改写window上的属性。所以只能在单个子应用模式下使用。</li></ul><div class="notion-text notion-block-bc8c4727452245aea65dbf9731e8bbd7"><b>多应用的代理沙箱</b></div><div class="notion-text notion-block-023e5a00d1c7423e9eb384b48c468afb">在激活时，为每个子应用创建一个空的沙盒对象，拦截window访问，对访问的属性先从沙盒对象取，如果没有则从window里取。当修改属性，则直接在空沙盒对象中修改。避免污染全局window。这样就可以在多子应用模式下使用。</div><div class="notion-blank notion-block-4e43a2f00f794a2abf9f68bae66c4e95"> </div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-e60f3dc8f97140efb1079667e7e35cf6" data-id="e60f3dc8f97140efb1079667e7e35cf6"><span><div id="e60f3dc8f97140efb1079667e7e35cf6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e60f3dc8f97140efb1079667e7e35cf6" title="storage隔离"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">storage隔离</span></span></h4><ul class="notion-list notion-list-disc notion-block-d6fdec5d28c6460a855e3a42943d147f"><li>靠自觉，在key前加上应用名作为前缀。</li></ul><ul class="notion-list notion-list-disc notion-block-819ea1bcdca4495282028f976d57fd38"><li>重写Storage方法，自动在key前加上应用名作为前缀。</li></ul><ul class="notion-list notion-list-disc notion-block-20e0d3236bde4fb68669926275fec233"><li>封装二方包，使用二方包进行storage操作，自动在key前加上应用名作为前缀。</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-c4b8abbfc8f94f31ace7edca426c6117" data-id="c4b8abbfc8f94f31ace7edca426c6117"><span><div id="c4b8abbfc8f94f31ace7edca426c6117" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c4b8abbfc8f94f31ace7edca426c6117" title="消息通信"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>消息通信</b></span></span></h3><div class="notion-text notion-block-90a096de31b048909e38c8506c2fa354">合理划分应用，可以避免频繁的跨应用通信。同时应当避免子应用之间直接通信。</div><div class="notion-text notion-block-5bc4d8289cb14affbda3d5beeb784714">常见的消息通信机制可以除此之外，</div><ol start="1" class="notion-list notion-list-numbered notion-block-edf70956fa154254a1d941cc41a2b2de"><li>基于storage，然后用事件监听。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-9cb858ff9d6743378865efe358c7db2c"><li>通过原生 CustomEvent 类实现，子应用通过 dispatchEvent 和 addEventListener 来对自定义事件进行下发和监听。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-39142e1630c14d258b296a05c1b40c17"><li>基于props传参的模式，所有微应用与主应用通信，主应用再通知微应用</li></ol><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-11923b75475e4d909c4d1e7ea42ec3a8" data-id="11923b75475e4d909c4d1e7ea42ec3a8"><span><div id="11923b75475e4d909c4d1e7ea42ec3a8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#11923b75475e4d909c4d1e7ea42ec3a8" title="依赖管理"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>依赖管理</b></span></span></h3><div class="notion-text notion-block-d05bea1ca5e943269d63d1c5425d9235">常见的微前端框架中，基座应用统一对子应用的状态进行管理。根据路由和子应用状态，按需触发生命周期函数，做请求加载、渲染、卸载等动作。而多个子应用间可能存在一些公共库的依赖。</div><div class="notion-text notion-block-309c535a568c414ebafc4cb1df5145cc">为减少这类资源的重复加载，通常可以借助 webpack5 的 Module Federation 在构建时进行公共依赖的配置，实现运行时依赖共享的能力。除了使用打包工具的能力，也可以从代码层面通过实现类 external 功能对公共依赖进行管理。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-d7c799104b6345709baeb28486803f8c" data-id="d7c799104b6345709baeb28486803f8c"><span><div id="d7c799104b6345709baeb28486803f8c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d7c799104b6345709baeb28486803f8c" title="资源共享"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">资源共享</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-04b5bd3cbf3a481295d40be04d0737e5" data-id="04b5bd3cbf3a481295d40be04d0737e5"><span><div id="04b5bd3cbf3a481295d40be04d0737e5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#04b5bd3cbf3a481295d40be04d0737e5" title="发布/订阅模式 EventBus"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b><b>发布/订阅模式 EventBus</b></b></span></span></h4><div class="notion-text notion-block-c59f0561b66542b2bf714248b90e69ee">主应用注册 EventBus，然后通过 props 下发微应用，这样微应用既有主应用的EventBus 也可以有自己的 EventBus</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-fd29da0810ad46e3a46bbb36b1822642" data-id="fd29da0810ad46e3a46bbb36b1822642"><span><div id="fd29da0810ad46e3a46bbb36b1822642" class="notion-header-anchor"></div><a class="notion-hash-link" href="#fd29da0810ad46e3a46bbb36b1822642" title="关联技术"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>关联技术</b><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://febook.hzfe.org/awesome-interview/book4/engineer-mfa#%E5%85%B3%E8%81%94%E6%8A%80%E6%9C%AF"><b></b></a></span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-876c49d095064a739a3a87847f0dd206" data-id="876c49d095064a739a3a87847f0dd206"><span><div id="876c49d095064a739a3a87847f0dd206" class="notion-header-anchor"></div><a class="notion-hash-link" href="#876c49d095064a739a3a87847f0dd206" title="Web Components"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>Web Components</b><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://febook.hzfe.org/awesome-interview/book4/engineer-mfa#web-components"><b></b></a></span></span></h4><div class="notion-text notion-block-271c8faa0a0f4dc68837d44bd7ce32aa">Web Components 允许开发者不借助框架，实现一些可重用的自定义组件。构建一个 Web Components 通常使用到 customElements、Shadow DOM 的 API，和 templates、slot 标签。</div><div class="notion-text notion-block-ecc76e8e76c04ee68477254a6cd51587">基于 Web Components 开发，可以天然契合微前端的一些特性：技术栈无关，应用间隔离。但兼容性较差，不支持 IE。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-6584d91caaab4541bcc06a6e283fd833" data-id="6584d91caaab4541bcc06a6e283fd833"><span><div id="6584d91caaab4541bcc06a6e283fd833" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6584d91caaab4541bcc06a6e283fd833" title="iframe"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>iframe</b><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://febook.hzfe.org/awesome-interview/book4/engineer-mfa#iframe"><b></b></a></span></span></h4><div class="notion-text notion-block-c96fff80ed394e91adcb11fe4c9ef313">iframe 常用于将应用嵌入另一个宿主应用中。只使用 iframe 方案引入子应用的好处是浏览器兼容性强，接入成本低，样式及脚本天然隔离。但是由于 iframe 和宿主应用完全隔离，各自独立运行，导致了诸多限制，如：</div><ol start="1" class="notion-list notion-list-numbered notion-block-2ad4291dbd7a48f88edbf92ac2b2bacd"><li>资源无法共享；</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-3c0bc489488c4a3aaff726366b7e7297"><li>iframe 中的 UI 无法跨越 iframe 窗口边界；</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-e83b8e3589234ed786290d99914c7178"><li>刷新页面时 iframe 中的路由状态丢失；</li></ol><div class="notion-text notion-block-a383e56e20094b8c949d6532bbe6faa2">目前腾讯提供了一个新的微前端实施思路：借助 ShadowRoot 渲染子应用的 DOM；iframe 负责运行子应用的 JavaScript 代码，从而实现 JS 沙箱和 CSS 隔离能力。另外，在保证子应用和主应用同源的前提下，将子应用的路由变化同步到主应用中，从而保证刷新页面后，路由地址正常。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-a88b43ad048547b3b085cadfafbbaa2c" data-id="a88b43ad048547b3b085cadfafbbaa2c"><span><div id="a88b43ad048547b3b085cadfafbbaa2c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a88b43ad048547b3b085cadfafbbaa2c" title="webpack5 Module Federation"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>webpack5 Module Federation</b><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://febook.hzfe.org/awesome-interview/book4/engineer-mfa#webpack5-module-federation"><b></b></a></span></span></h4><div class="notion-text notion-block-fe0296328e68445c83ba21d9e7fe8e57">目前市面上的微前端方案中，有基于 Module Federation 的微前端框架实践。Module Federation 是 webpack 提供的一个插件，他支持通过配置以下核心参数，在打包构建阶段确定集成策略：</div><ol start="1" class="notion-list notion-list-numbered notion-block-f3de5bbcd0b047179427396eb8590934"><li>exposes 参数，指定应用可以描述当自己作为被加载的远程模块时，可暴露给其他应用使用的模块路径。</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-098497cb3de94b4795f8a15772d8d7ea"><li>remotes 参数，指定应用可以从远端加载的远程模块地址。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-afc798261e5447909cab53c5928cafe6"><li>shared 参数，指定应用可以与其他远程模块共享的依赖（精确到版本）。</li></ol><div class="notion-blank notion-block-10ee8c7044fe4c25a20fc155f0c08ca6"> </div><div class="notion-blank notion-block-e9f2a5f82a984c2783a020d555a30fa6"> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-036d0d0d153040de86a5d828871d8a30" data-id="036d0d0d153040de86a5d828871d8a30"><span><div id="036d0d0d153040de86a5d828871d8a30" class="notion-header-anchor"></div><a class="notion-hash-link" href="#036d0d0d153040de86a5d828871d8a30" title="参考"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-fd69066ce53b48d3ad03bbaecbf9d6cb" href="https://segmentfault.com/a/1190000043979113"><div><div class="notion-bookmark-title">segmentfault.com</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-text">https://segmentfault.com/a/1190000043979113</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-306d0aa0c9624dee8f35f6ad33a31d64" href="https://juejin.cn/post/7087766740599308318?searchId=202311141637001840ED9E51A037E9DFE6"><div><div class="notion-bookmark-title">微前端的总结分享（演讲稿版——浅析 qiankun 基本原理） - 掘金</div><div class="notion-bookmark-description">时值当下，作为一名合格的前端开发人员，我相信你一定会有一个很明显的感觉：Web 业务日益复杂化和多元化，前端的职责越来越重要，战场越来越多样，应用也越来越复杂，前端开发已经由WebPage 模式</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=306d0aa0-c962-4dee-8f35-f6ad33a31d64" alt="微前端的总结分享（演讲稿版——浅析 qiankun 基本原理） - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/7087766740599308318?searchId=202311141637001840ED9E51A037E9DFE6</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-2de4142d40ee4a84bafa0e7f3e512bc8" href="https://juejin.cn/post/6980565734174752805#heading-23"><div><div class="notion-bookmark-title">微前端-技术方案总结 - 掘金</div><div class="notion-bookmark-description">开始写这篇文章的起因是公司的大前端部门开始实现公司自己的微前端框架 在和大前端部门的合作中，对微前端相关的知识和技术点、难点的总结 微前端是什么 为什么要有微前端 我们正常的一个单体应用，主要负责一个</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=2de4142d-40ee-4a84-bafa-0e7f3e512bc8" alt="微前端-技术方案总结 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/6980565734174752805#heading-23</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-6de1d005c8de4bf090f30b56f1b6be6a" href="https://juejin.cn/post/6938699791824060424?searchId=2023102615390282C4F3458A260D04E9AD"><div><div class="notion-bookmark-title">【得物技术】前端微服务 - 掘金</div><div class="notion-bookmark-description">“ 微前端 ”一词最早于2016年底在ThoughtWorks Technology Radar中提出。它将微服务的概念扩展到前端世界。当前的趋势是构建一个功能强大且功能强大的浏览器应用程序（又名单页应用程序），该应用程序位于微服务架构之上。随着时间的流逝，通常由独立团队开发的…</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=6de1d005-c8de-4bf0-90f3-0b56f1b6be6a" alt="【得物技术】前端微服务 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/6938699791824060424?searchId=2023102615390282C4F3458A260D04E9AD</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-f88fe4b4a9ab450a81ad1aad07512f87" href="https://mp.weixin.qq.com/s/o3s_c2MNemqzP8ZLvH8RHA"><div><div class="notion-bookmark-title">美业微前端的落地</div><div class="notion-bookmark-description">Weixin ID
                  FrontDev</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg?t=f88fe4b4-a9ab-450a-81ad-1aad07512f87" alt="美业微前端的落地" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://mp.weixin.qq.com/s/o3s_c2MNemqzP8ZLvH8RHA</div></div></div><div class="notion-bookmark-image"><img style="object-fit:cover" src="http://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib2kNNZiaoBJ2uE3E3AwxTuo2npCV37IibYmunTMozicyd5ExnHUKmFKiaktwOe3j8clDWRmby4CibGkFlA/0?wx_fmt=jpeg&amp;t=f88fe4b4-a9ab-450a-81ad-1aad07512f87" alt="美业微前端的落地" loading="lazy" decoding="async"/></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-862e434d87d74cde8cb343ebe481e420" href="https://juejin.cn/post/7098616772906975268#heading-8"><div><div class="notion-bookmark-title">微前端很好，为什么我却不使用? | 微前端原理剖析 - 掘金</div><div class="notion-bookmark-description">本文记录我对微前端原理的探索与思考，以及微前端框架qiankun项目实践。 当下前端所存在的一些问题 在技术浪潮的推动下，由vue、react所主导的单页面应用已成为主流，但在开发中，随着业务的深入和</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=862e434d-87d7-4cde-8cb3-43ebe481e420" alt="微前端很好，为什么我却不使用? | 微前端原理剖析 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/7098616772906975268#heading-8</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-3d84c2f6a97f40eb9192acb775bba0a3" href="https://juejin.cn/post/7069566144750813197?searchId=20240125111315DCA240BC74380970667D"><div><div class="notion-bookmark-title">万字长文-落地微前端 qiankun 理论与实践指北 - 掘金</div><div class="notion-bookmark-description">微前端的特性：“技术栈无关”，“独立开发、独立部署”，“环境隔离” 这意味着我们可以循序渐进的进行巨石应用的拆解，去技术升级、去架构尝试、去业务拆解等等。以低成本、低风险的进行，为项目带来更多可能性</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=3d84c2f6-a97f-40eb-9192-acb775bba0a3" alt="万字长文-落地微前端 qiankun 理论与实践指北 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/7069566144750813197?searchId=20240125111315DCA240BC74380970667D</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-9b2f4f14ddb74aeaa00575c177c20b21" href="https://juejin.cn/post/7221366548077707321"><div><div class="notion-bookmark-title">微前端：乾坤 VS 无界 - 掘金</div><div class="notion-bookmark-description">共同点： 当路由切换的时候，可以去加载对应应用的代码，让其跑在容器里。 差异点： 容器实现方案不同。</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=9b2f4f14-ddb7-4aea-a005-75c177c20b21" alt="微前端：乾坤 VS 无界 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/7221366548077707321</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-a065185707d6436a9eb27eab4350af5f" href="https://juejin.cn/post/7254944931386163260"><div><div class="notion-bookmark-title">微前端的落地和治理实战 - 掘金</div><div class="notion-bookmark-description">微前端实现原理、框架选型之类的文章比较泛滥，我不打算讲这些玩意，本文主要来源于笔者过去一年落地微前端的一手经验，尽量不讲技术细节，而是讲一个体系化的方案是怎么搭建起来。 文章较长，耐心看完保证会有收获</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/static/favicons/apple-touch-icon.png?t=a0651857-07d6-436a-9eb2-7eab4350af5f" alt="微前端的落地和治理实战 - 掘金" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://juejin.cn/post/7254944931386163260</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-851a983e1345442a9b831b9d52b63219" href="https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html"><div><div class="notion-bookmark-title">微前端在美团外卖的实践</div><div class="notion-bookmark-description">微前端是一种利用微件拆分来达到工程拆分治理的方案，可以解决工程膨胀、开发维护困难等问题。随着前端业务场景越来越复杂，微前端这个概念最近被提起得越来越多。</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/android-icon-192x192.png?v=Whistle&amp;t=20181017-1r&amp;t=851a983e-1345-442a-9b83-1b9d52b63219" alt="微前端在美团外卖的实践" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html</div></div></div></a></div></main></div>]]></content>
    </entry>
</feed>